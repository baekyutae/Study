
# 정의 

**REST**(Representational State Transfer)는 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 위한 네트워크 아키텍처 스타일
주로 HTTP를 통해 요청-응답 방식으로 작동하며, 일반적으로 요청 및 응답 본문에 JSON 데이터 형식을 사용


# REST의 6가지 제약 조건 (핵심 설계 원칙)


### 1. **Uniform Interface (인터페이스 일관성):** 
- 
	클라이언트와 서버가 서로 독립적으로 발전할 수 있도록, 둘 사이의 상호작용 방식을 통일(Uniform)하는 것을 목적으로 한다.<br>
	이렇게 하면 서버의 내부가 바뀌어도 인터페이스가 동일하므로 클라이언트는 영향을 받지 않음

	4가지 세부원칙이 존재

	1) 자원 기반 (Resource-Based)
	
		모든 데이터(자원)는 고유한 이름표인 **URI**로 식별되어야한다.
		서버는 내부 db를 통쨰로 클라이언트에게 보내는 대신 그 자원을 클라이언트가 이해할 수 있는 특정한 형태(json, xml등)으로 가공해서 전달한다<br>
	2) 표현을 통한 자원 조작 (Manipulation of Resources Through Representations)
	
		클라이언트가 자원의 '표현'(데이터 + 메타데이터)을 가지고 있다면, 이것만으로도 서버의 원본 자원을 수정하거나 삭제할 수 있어야 한다
		즉 데이터를 전달하는 것 자체가 명령이 된다.<br>
	3) 자기 서술적 메시지 (Self-descriptive Messages)

		메시지는 스스로를 어떻게 해석해야 하는지 모든 정보를 담고 있어야 한다
		단순히 데이터만 보내는 게 아니라, "이 데이터는 JSON이야", "이건 UTF-8로 인코딩됐어" 같은 정보를 헤더(Header)나 미디어 타입(Media Type)**을 통해 명시
		
		```http
		HTTP/1.1 200 OK
		Content-Type: application/json; charset=utf-8
		Cache-Control: max-age=3600

		{"name": "biblio"}
		
		-> 헤더를 통해 이건 json이고 utf8로 읽어야 하며 1시간 동안은 캐싱이 가능하다고 설명
		```

	4) HATEOAS (Hypermedia as the Engine of Application State)

	애플리케이션의 상태 전이(다음 행동)가 하이퍼미디어(링크)를 통해 이루어져야 한다.
	
	상태: 현재 사용자가 무엇을 하고 있는지
	상태전이 예시 : **로그인 상태** → (로그아웃 링크 클릭) → 비로그인 상태

	```json
	{ "id": 10, 
	  "title": "REST API 공부 중", 
	  "content": "HATEOAS는 정말 어렵네요.", 
	  "_links": { 
		  "self": { "href": "/posts/10" }, 
		  "update": { "href": "/posts/10/update" }, 
		  "delete": { "href": "/posts/10/delete" }, 
		  "list": { "href": "/posts" } 
		  } 
	}
	```

	다음과 같이 데이터와 함께 할수 있는 행동들을 링크로 묶어준다

	장점:
	1.클라이언트와 서버의 느슨한 결합:
	서버가 api경로를 변경하더라도 클라이언트 코드를 수정할 필요가 거의 없다. 클라이언트는 하드코딩된 URL(`'/api/v1/users'`)을 사용하는 대신, 서버가 보내준 링크(`links.self.href`)를 그대로 따라가기 때문<br>
	2.동적인 권한 제어:
	사용자 권한에 따라 응답에 포함되는 링크를 다르게 보낼 수 있다.<br>
	- **일반 사용자:** 조회 링크만 포함

	- **관리자:** 수정 및 삭제 링크까지 포함 클라이언트는 단순히 "링크가 있느냐 없느냐"에 따라 UI에서 버튼을 보여주거나 숨기면 된다

	단점
	1. 높은 구현 난이도와 공수:
		단순히 데이터만 보내는 것이 아니라, 매 응답마다 연관된 링크들을 계산해서 넣어야 한다<br>
	2. 네트워크 오버헤드:
		응답 본문에 실제 데이터 외에도 수많은 링크 정보(`_links`)가 포함되므로 메시지 크기가 커진다.
		
### 2. **Stateless (무상태성):

REST 아키텍처에서 "무상태"란 서버가 클라이언트의 이전 요청이나 현재 상태(Context)를 기억하지 않는다는 것을 의미


- **독립적인 요청:** 모든 HTTP 요청은 그 자체로 완전해야 한다. 즉, 서버가 요청을 처리하는 데 필요한 모든 정보(인증 정보, 상태 값 등)가 요청 패킷(URI, 쿼리 파라미터, 바디, 헤더) 안에 모두 포함되어야 함
    
- **세션 부재:** 세션/쿠키 기반은 서버가 클라이언트의 상태(세션)를 유지했지만, REST에서는 서버가 세션 정보를 저장하지 않는다

상태(State)의 두 가지 종류

| **구분**                                             | **설명**                                     | **관리 주체** | **특징**                                   |
| -------------------------------------------------- | ------------------------------------------ | --------- | ---------------------------------------- |
| **애플리케이션 상태**<br><br>  <br><br>(Application State) | 요청을 처리하기 위한 문맥 정보 (예: 로그인 세션, 현재 페이지 위치 등) | **클라이언트** | 요청마다 달라질 수 있으며, 클라이언트가 요청 시마다 서버로 전송해야 함 |
| **리소스 상태**<br><br>  <br><br>(Resource State)       | 서버의 데이터베이스 등에 저장된 실제 데이터                   | **서버**    | 누가 요청하든 동일하게 유지되는 지속적인 데이터               |
<br>REST에서는 이 둘의 관리 주체가 다르다

**무상태성을 지향하는 이유**

- **로드 밸런싱의 자유:** 로드 밸런서는 "세션 어피니티(Session Affinity, 특정 사용자를 계속 같은 서버로 연결해 주는 기술)"를 신경 쓸 필요가 없다. 어떤 서버가 요청을 받든 요청 안에 모든 정보가 있으므로 처리가 가능.

- **서버 부하 저하**: 서버가 각 클라이언트의 세션 정보를 유지하거나 관리할 필요가 없으므로 서버 부하가 줄어든다.

**반대로 stateful을 지향해야하는 경우**

- **실시간 통신 (WebSocket):** 채팅, 실시간 게임, 주식 시세 등은 클라이언트와 서버가 연결된 상태(Stateful)를 계속 유지해야 한다. (예: TCP/IP 소켓 연결)
    
- **보안이 매우 중요한 경우:** JWT 같은 토큰 기반(무상태) 인증은 한번 발급하면 서버에서 강제로 만료시키기가 까다로움(JWT는 발급해 준 뒤에는 서버가 그 토큰의 존재를 잊어버리기 때문). 반면 세션 방식(상태 유지)은 서버가 세션을 지워버리면 즉시 로그아웃시킬 수 있어 제어권이 서버에 있다. 

절충안으로 서버(Application Server)는 무상태로 만들되, 상태 정보는 별도의 고속 저장소(Redis 등)에 저장하는 방식을 사용하기도 함

### 3. **Cacheable (캐시 가능성):

HTTP의 캐싱 기능을 사용하여 효율성을 높일 수 있어야 한다.

**캐싱(Caching)이란?** 

클라이언트(또는 중간 서버)가 서버로부터 받은 응답 데이터를 저장해 두었다가, 나중에 동일한 요청이 왔을 때 서버에 다시 물어보지 않고 **저장해 둔 데이터를 재사용**하는 것

**서버의 의무 (Implicit or Explicit)**

서버는 응답 헤더(HTTP Header)에 다음과 같은 정보를 포함해야 한다.

- **Cacheable (저장 가능):** "이 데이터는 앞으로 1시간 동안은 똑같을 거야. 그러니까 1시간 동안은 나한테 다시 물어보지 말고 저장한 거 써."
    
- **Non-cacheable (저장 불가):** "이 데이터는 실시간 주식 가격처럼 매초 바뀌니까 절대 저장하지 마. 필요할 때마다 나한테 새로 요청해.

**캐싱을 하는 이유**
잘 관리된 캐싱은 클라이언트와 서버 간의 상호작용을 부분적, 혹은 완전히 제거해준다

1. 성능향상: 클라이언트가 네트워크를 타지 않고 내부 저장소에서 바로 데이터를 가져오므로 속도가 빨라진다<br>
2. 확장성(Scalability): 서버 입장에서는 똑같은 요청을 반복해서 처리할 필요가 없으므로 부하가 줄어들고, 더 많은 사용자를 감당 가능

**다만** 서버의 데이터는 바뀌었는데 클라이언트가 계속 옛날(캐시된) 데이터를 쓰고 있다면 문제가 된다. 때문에 캐시된 데이터의 만료시간을 잘 정하는 것이 중요하다
### 4. **Client-Server (클라이언트-서버 구조):**

클라이언트는 사용자 경험(UI)에, 서버는 데이터 처리(Business Logic)에만 집중하여 서로의 내부 구현을 몰라도 독립적으로 발전할 수 있게 하는 원칙

**장점**

1. 독립적인 진화 (Independent Evolution):
	API 명세(약속)만 지킨다면, 백엔드 로직을 다 뜯어고쳐도 프론트엔드는 수정할 필요가 없다.
	
2. 이식성 (Portability):서버 하나만 잘 만들어두면 웹, 모바일(iOS/Android), 스마트 워치 등 다양한 기기(Client)에서 데이터를 가져다 쓸 수 있다

3. 확장성 (Scalability): 사용자가 갑자기 늘어나면? 클라이언트는 그대로 두고 서버만 여러 대로 늘리면(Scale-out) 된다.

**단점**
### 5. **Layered System (계층화 시스템):** 보안, 로드 밸런싱 등을 위해 중간 매체(프록시, 게이트웨이)를 둘 수 있습니다.
    
### 6. **Code on Demand (선택적 사항):** 필요에 따라 서버에서 클라이언트로 실행 가능한 코드를 전송할 수 있습니다.
    

# 주요 HTTP 메서드 

리소스에 대해 어떤 동작을 할지 정의

- **GET:** 리소스 조회 (Read)
    
- **POST:** 새로운 리소스 생성 (Create)
    
- **PUT:** 리소스 전체 수정 (Update)
    
- **PATCH:** 리소스 일부 수정 (Partial Update)
    
- **DELETE:** 리소스 삭제 (Delete)
    

\+ 리소스 조회시 GET 대신 POST를 사용하는 경우

1. 쿼리 파라미터가 너무 길거나 복잡할 때
<br>
	GET 방식은 데이터를 URL의 쿼리 스트링(`?key=value`)에 담는다. 하지만 브라우저나 웹 서버, 프록시 서버마다 **URL 길이 제한**이 존재<br>
	때문에 복잡한 필터링 조건, 수십 개의 ID 목록을 조회할 때, 혹은 매우 긴 JSON 구조의 검색 조건을 보낼 때. GET 방식으로 조회가 안되는 경우가 있다.<BR>
    이를 해결하기 위해 데이터를 **HTTP Body**에 담을 수 있는 POST를 사용<BR>
    
2.보안 및 민감한 정보 포함
<BR>
	GET 요청은 데이터가 URL에 그대로 노출된다
	URL은 브라우저 히스토리, 서버 액세스 로그, 보안 장비 로그에 **평문으로 기록**될 가능성이 높다. 때문에 Body에 데이터를 담는 POST가 상대적으로 보안 로그 측면에서 안전 하다.

**GET vs POST: 캐싱(Caching)의 차이**

캐싱은 똑같은 요청이 오면, 서버까지 가지 않고 저장해둔 결과를 바로 주는 것
기준은 "이 요청이 똑같은 요청인가?"를 판단하는 키(Key)

(1) GET의 캐싱: "URL이 같으면 같은 결과다"

클라이언트가 GET으로 요청하면 브라우저는 URL을 Key로 사용해 저장된 데이터가 있는지 확인하고 있으면 서버 조회 없이 반환

GET은 서버의 데이터를 변환하지 않으므로(Idempotent) 이전에 조회한 데이터를 이번에 그대로 반환해도 문제 없다 판단

(단 `Cache-Control` 헤더로 유효기간을 설정)


(2) POST의 캐싱: "URL이 같아도 내용은 다를 수 있다"

 URL이 같아도 Body 내용에 따라 결과가 달라져야 함.
 
하지만 브라우저는 URL만 식별자로 쓰기 때문에, POST 요청을 캐싱하면 다른 검색 조건(Body)을 보냈는데도, 이전 검색 결과가 나오는 오류가 발생함. 따라서 브라우저는 기본적으로 POST 응답을 캐싱하지 않음.

대신 백엔드 서버(Application Level)에서는 캐싱이 가능함.

개발자가 직접 요청 Body 전체를 해시(Hash)값으로 변환하여 고유 키(Key)를 생성하고, 이를 Redis 등에 저장해서 사용함.


# Resource naming (자원의 표현)

- **명사 사용:** URL에는 동사 대신 명사를 사용 (예: `/getUsers` (X) → `/users` (O))
    
- **컬렉션 비유:** 리소스의 집합은 복수형으로 표현 (예: `/users/123`)


# Http Status Code

| **상태 코드** | **이름 (Status Name)**      | **설명 (Description)**                         | **주요 활용 사례**                           |
| --------- | ------------------------- | -------------------------------------------- | -------------------------------------- |
| **200**   | **OK**                    | 일반적인 **성공**을 의미하는 가장 흔한 코드.                  | GET(조회), PUT/PATCH(수정) 성공 시            |
| **201**   | **CREATED**               | **리소스 생성 성공**을 의미 (POST/PUT)                 | 새로운 데이터 생성 시 (Location 헤더 포함 권장)       |
| **204**   | **NO CONTENT**            | 요청은 성공했으나 **응답 본문(Body)에 담을 내용이 없음**을 의미     | DELETE 성공 시, 혹은 수정 후 반환할 데이터가 없을 때     |
| **400**   | **BAD REQUEST**           | 클라이언트의 요청이 잘못되어 서버가 처리할 수 없는 상태              | 필수 데이터 누락, 유효성 검사(Validation) 실패       |
| **401**   | **UNAUTHORIZED**          | 인증 토큰이 없거나 **유효하지 않은 인증** 상태                 | 로그인이 필요하거나 토큰이 만료된 경우                  |
| **403**   | **FORBIDDEN**             | 사용자가 누구인지 알지만, **해당 권한이 없는** 상태              | 일반 유저가 관리자 페이지에 접근할 때                  |
| **404**   | **NOT FOUND**             | 요청한 리소스를 **찾을 수 없음**을 의미                     | 존재하지 않는 ID 조회, 잘못된 URL 경로              |
| **405**   | **METHOD NOT ALLOWED**    | URL은 존재하지만 해당 **HTTP 메서드를 지원하지 않음**을 의미      | 특정 아이템에 POST 요청 시 (이때 `Allow` 헤더 필수)   |
| **409**   | **CONFLICT**              | 서버의 현재 상태와 **리소스 충돌**이 발생한 상태                | **중복된 데이터**(이메일 등) 생성 시도 시             |
| **429**   | **Too Many Requests**     | 클라이언트가 지정된 시간 내에 너무 많은 요청을 보냈음을 나타낸다         | API 서비스에서 사용자별 분당/일일 호출 허용량을 초과했을 때 반환 |
| **500**   | **INTERNAL SERVER ERROR** | 서버 내부 로직 오류로 인한 **예외(Exception)** 발생 시 나타난다. | 코드 버그, DB 연결 실패 등 (직접 반환 금지)           |

# 멱등성(Idempotence)

- 동일한 요청을 여러 번 수행해도 결과가 같은 성질 (예: GET, PUT, DELETE는 멱등성이 있으나, POST는 반복 시 새로운 데이터가 계속 생기므로 멱등성이 없음)

# 안정성(Saftey)

### 정의

안정성은HTTP 명세에서 **서버의 리소스를 수정하지 않는 메서드**로 정의

즉 데이터가 변하거나 삭제될 위험이 없다는 뜻 == 읽기 전용 작업

클라이언트가 안전한 메서드를 사용하여 요청을 보낼 때, 서버에 어떠한 부작용(Side Effects)도 발생시키지 않아야 한다 그리고 여기서 '부작용'이란 데이터의 생성, 수정, 삭제 등을 의미

### 안전하다고 간주되는 HTTP 메서드 

**GET, HEAD, OPTIONS, TRACE** 가 있다

- **GET**: 데이터를 조회만 함. 

- **HEAD**: 데이터 본문은 빼고 헤더 정보만 가져옴.
    
- **OPTIONS**: 해당 서버가 어떤 메서드를 지원하는지 물어봄.
    
- **TRACE**: 요청이 서버에 도달하는 경로를 테스트함.

### 안전한 메서드의 이점

안전한 메서드를 사용하는 핵심 이점은 캐싱이 가능(Cacheable)하고 멱등(Idempotent)하다는 것<br>

서버의 데이터를 건드리지 않기 때문에, 결과를 복사해서 저장해두었다가 나중에 다시 써도 문제가 없다는 뜻 특히 GET 요청은 성능 향상을 위해 캐싱될 수 있다.

메서드의 안전성을 유지하면 웹 서비스의 **확장성, 캐싱 능력, 그리고 전반적인 신뢰성**이 향상 된다.

갑자기 왜 확장성이 향상될까?

서버 여러 대를 수평으로 늘릴(Scale-out) 때, 데이터를 바꾸지 않는 GET 요청은 어떤 서버로 보내든 상관없으므로 향상된다.

또한 클라이언트가 실수로 안전하지 않은 요청을 여러 번 보냈을 때 발생할 수 있는 의도치 않은 결과(데이터 중복 생성 등)를 방지한다.


멱등성과의 차이점:
안전한 메서드는 서버의 데이터를 절대 바꾸지 않지만 멱등성 메서드는 서버의 데이터는 바꿀 수 있지만 여러번 보내도 결과는 동일한 것

즉 모든 안전한 메서드는 멱등하지만 모든 멱등한 메서드가 안전하지는 않음
