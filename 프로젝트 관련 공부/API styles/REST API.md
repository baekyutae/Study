
# 정의 

**REST**(Representational State Transfer)는 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 위한 네트워크 아키텍처 스타일입니다. 한마디로 웹의 장점을 최대한 활용할 수 있는 API 설계 규칙


# REST의 6가지 제약 조건 (핵심 설계 원칙)


- **Uniform Interface (인터페이스 일관성):** URI로 지정된 리소스에 대해 일관된 조작 방식을 가져야 합니다.
    
- **Stateless (무상태성):** 각 요청은 독립적이며, 서버는 클라이언트의 상태(세션 등)를 저장하지 않습니다.
    
- **Cacheable (캐시 가능성):** HTTP의 캐싱 기능을 사용하여 효율성을 높일 수 있어야 합니다.
    
- **Client-Server (클라이언트-서버 구조):** 서로 독립적으로 분리되어 개발 및 진화할 수 있어야 합니다.
    
- **Layered System (계층화 시스템):** 보안, 로드 밸런싱 등을 위해 중간 매체(프록시, 게이트웨이)를 둘 수 있습니다.
    
- **Code on Demand (선택적 사항):** 필요에 따라 서버에서 클라이언트로 실행 가능한 코드를 전송할 수 있습니다.
    

# 주요 HTTP 메서드 

리소스에 대해 어떤 동작을 할지 정의

- **GET:** 리소스 조회 (Read)
    
- **POST:** 새로운 리소스 생성 (Create)
    
- **PUT:** 리소스 전체 수정 (Update)
    
- **PATCH:** 리소스 일부 수정 (Partial Update)
    
- **DELETE:** 리소스 삭제 (Delete)
    

\+ 리소스 조회시 GET 대신 POST를 사용하는 경우

1. 쿼리 파라미터가 너무 길거나 복잡할 때
<br>
	GET 방식은 데이터를 URL의 쿼리 스트링(`?key=value`)에 담는다. 하지만 브라우저나 웹 서버, 프록시 서버마다 **URL 길이 제한**이 존재<br>
	때문에 복잡한 필터링 조건, 수십 개의 ID 목록을 조회할 때, 혹은 매우 긴 JSON 구조의 검색 조건을 보낼 때. GET 방식으로 조회가 안되는 경우가 있다.<BR>
    이를 해결하기 위해 데이터를 **HTTP Body**에 담을 수 있는 POST를 사용<BR>
    
2.보안 및 민감한 정보 포함
<BR>
	GET 요청은 데이터가 URL에 그대로 노출된다
	URL은 브라우저 히스토리, 서버 액세스 로그, 보안 장비 로그에 **평문으로 기록**될 가능성이 높다. 때문에 Body에 데이터를 담는 POST가 상대적으로 보안 로그 측면에서 안전 하다.

**GET vs POST: 캐싱(Caching)의 차이**

캐싱은 똑같은 요청이 오면, 서버까지 가지 않고 저장해둔 결과를 바로 주는 것
기준은 "이 요청이 똑같은 요청인가?"를 판단하는 키(Key)

(1) GET의 캐싱: "URL이 같으면 같은 결과다"

클라이언트가 GET으로 요청하면 브라우저는 URL을 Key로 사용해 저장된 데이터가 있는지 확인하고 있으면 서버 조회 없이 반환

GET은 서버의 데이터를 변환하지 않으므로(Idempotent) 이전에 조회한 데이터를 이번에 그대로 반환해도 문제 없다 판단

(단 `Cache-Control` 헤더로 유효기간을 설정)


(2) POST의 캐싱: "URL이 같아도 내용은 다를 수 있다"

 URL이 같아도 Body 내용에 따라 결과가 달라져야 함.
 
하지만 브라우저는 URL만 식별자로 쓰기 때문에, POST 요청을 캐싱하면 다른 검색 조건(Body)을 보냈는데도, 이전 검색 결과가 나오는 오류가 발생함. 따라서 브라우저는 기본적으로 POST 응답을 캐싱하지 않음.

대신 백엔드 서버(Application Level)에서는 캐싱이 가능함.

개발자가 직접 요청 Body 전체를 해시(Hash)값으로 변환하여 고유 키(Key)를 생성하고, 이를 Redis 등에 저장해서 사용함.


# Resource naming (자원의 표현)

- **명사 사용:** URL에는 동사 대신 명사를 사용 (예: `/getUsers` (X) → `/users` (O))
    
- **컬렉션 비유:** 리소스의 집합은 복수형으로 표현 (예: `/users/123`)


# Http Status Code

| **상태 코드** | **이름 (Status Name)**      | **설명 (Description)**                         | **주요 활용 사례**                         |
| --------- | ------------------------- | -------------------------------------------- | ------------------------------------ |
| **200**   | **OK**                    | 일반적인 **성공**을 의미하는 가장 흔한 코드.                  | GET(조회), PUT/PATCH(수정) 성공 시          |
| **201**   | **CREATED**               | **리소스 생성 성공**을 의미 (POST/PUT)                 | 새로운 데이터 생성 시 (Location 헤더 포함 권장)     |
| **204**   | **NO CONTENT**            | 요청은 성공했으나 **응답 본문(Body)에 담을 내용이 없음**을 의미     | DELETE 성공 시, 혹은 수정 후 반환할 데이터가 없을 때   |
| **400**   | **BAD REQUEST**           | 클라이언트의 요청이 잘못되어 서버가 처리할 수 없는 상태              | 필수 데이터 누락, 유효성 검사(Validation) 실패     |
| **401**   | **UNAUTHORIZED**          | 인증 토큰이 없거나 **유효하지 않은 인증** 상태                 | 로그인이 필요하거나 토큰이 만료된 경우                |
| **403**   | **FORBIDDEN**             | 사용자가 누구인지 알지만, **해당 권한이 없는** 상태              | 일반 유저가 관리자 페이지에 접근할 때                |
| **404**   | **NOT FOUND**             | 요청한 리소스를 **찾을 수 없음**을 의미                     | 존재하지 않는 ID 조회, 잘못된 URL 경로            |
| **405**   | **METHOD NOT ALLOWED**    | URL은 존재하지만 해당 **HTTP 메서드를 지원하지 않음**을 의미      | 특정 아이템에 POST 요청 시 (이때 `Allow` 헤더 필수) |
| **409**   | **CONFLICT**              | 서버의 현재 상태와 **리소스 충돌**이 발생한 상태                | **중복된 데이터**(이메일 등) 생성 시도 시           |
| **500**   | **INTERNAL SERVER ERROR** | 서버 내부 로직 오류로 인한 **예외(Exception)** 발생 시 나타난다. | 코드 버그, DB 연결 실패 등 (직접 반환 금지)         |

# 멱등성(Idempotence)

- 동일한 요청을 여러 번 수행해도 결과가 같은 성질 (예: GET, PUT, DELETE는 멱등성이 있으나, POST는 반복 시 새로운 데이터가 계속 생기므로 멱등성이 없음)

# 안정성(Saftey)

### 정의

안정성은HTTP 명세에서 **서버의 리소스를 수정하지 않는 메서드**로 정의

즉 데이터가 변하거나 삭제될 위험이 없다는 뜻 == 읽기 전용 작업

클라이언트가 안전한 메서드를 사용하여 요청을 보낼 때, 서버에 어떠한 부작용(Side Effects)도 발생시키지 않아야 한다 그리고 여기서 '부작용'이란 데이터의 생성, 수정, 삭제 등을 의미

### 안전하다고 간주되는 HTTP 메서드 

**GET, HEAD, OPTIONS, TRACE** 가 있다

- **GET**: 데이터를 조회만 함. 

- **HEAD**: 데이터 본문은 빼고 헤더 정보만 가져옴.
    
- **OPTIONS**: 해당 서버가 어떤 메서드를 지원하는지 물어봄.
    
- **TRACE**: 요청이 서버에 도달하는 경로를 테스트함.

### 안전한 메서드의 이점

안전한 메서드를 사용하는 핵심 이점은 캐싱이 가능(Cacheable)하고 멱등(Idempotent)하다는 것<br>

서버의 데이터를 건드리지 않기 때문에, 결과를 복사해서 저장해두었다가 나중에 다시 써도 문제가 없다는 뜻 특히 GET 요청은 성능 향상을 위해 캐싱될 수 있다.

메서드의 안전성을 유지하면 웹 서비스의 **확장성, 캐싱 능력, 그리고 전반적인 신뢰성**이 향상 된다.

갑자기 왜 확장성이 향상될까?

서버 여러 대를 수평으로 늘릴(Scale-out) 때, 데이터를 바꾸지 않는 GET 요청은 어떤 서버로 보내든 상관없으므로 향상된다.

또한 클라이언트가 실수로 안전하지 않은 요청을 여러 번 보냈을 때 발생할 수 있는 의도치 않은 결과(데이터 중복 생성 등)를 방지한다.


멱등성과의 차이점:
안전한 메서드는 서버의 데이터를 절대 바꾸지 않지만 멱등성 메서드는 서버의 데이터는 바꿀 수 있지만 여러번 보내도 결과는 동일한 것

즉 모든 안전한 메서드는 멱등하지만 모든 멱등한 메서드가 안전하지는 않음
