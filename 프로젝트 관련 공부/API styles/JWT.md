
# JWT란

JWT(JSON Web Token)는 당사자 간에 정보를 JSON 객체 형태로 안전하게 전송하기 위한 개방형 표준(RFC 7519)이다.<br>
서버가 클라이언트의 상태를 기억할 필요 없는 무상태성(Stateless)을 띠기 때문에 서버 확장성이 뛰어나며, 현대 웹 애플리케이션의 인증(Authentication) 및 인가(Authorization)에서 표준으로 사용된다.

# JWT의 구조 (Header.Payload.Signature)

JWT는 점(`.`)을 구분자로 사용하여 세 부분으로 나뉨.

- **Header (헤더):** * 토큰의 타입(`typ`: JWT)과 서명 생성에 사용된 암호화 알고리즘(`alg`: HS256, RS256 등) 정보를 담음.
    
    - 이 정보는 Base64Url로 인코딩됨.
        
- **Payload (페이로드):** * 서버와 클라이언트가 주고받을 실제 데이터인 '클레임(Claim)'이 들어감.
    
    - 유저 식별자(`sub`), 만료 시간(`exp`), 권한(`role`) 등의 정보가 포함됨.
        
    - **주의점:** 암호화(Encryption)가 아닌 단순 Base64Url 인코딩이므로, 누구나 디코딩해서 내용을 읽을 수 있음. 따라서 비밀번호 같은 민감 정보는 절대 넣으면 안 됨.
        
- **Signature (서명):** * 토큰이 중간에 위변조되지 않았음을 검증하는 가장 중요한 부분임.
    
    - 인코딩된 헤더와 인코딩된 페이로드를 합친 뒤, 서버만 알고 있는 비밀키(Secret Key)를 사용해 헤더에 명시된 알고리즘으로 해싱하여 만듦.
        
    - 해커가 페이로드의 데이터를 조작하더라도 서버의 비밀키를 모르기 때문에 올바른 서명을 만들 수 없고, 서버는 서명 불일치로 조작된 토큰을 즉시 걸러냄.

# Access / Refresh Token 흐름

토큰이 탈취당할 위험(보안)과 매번 로그인해야 하는 불편함(UX) 사이의 균형을 맞추기 위해 두 개의 토큰을 나누어 운용함.

- **Access Token:** 실제 API 접근 시 사용하는 '출입증'. 탈취 시 피해를 줄이기 위해 수명을 아주 짧게(예: 15분~1시간) 설정함.
    
- **Refresh Token:** Access Token이 만료되었을 때 새로운 출입증을 발급받기 위한 '교환권'. 수명을 길게(예: 1~2주) 설정하고 안전한 곳에 보관함.

**기본 동작 흐름:**

1. 사용자 로그인 성공 시 서버는 Access/Refresh Token을 모두 발급함.
    
2. 클라이언트는 API 요청 시 헤더에 Access Token을 실어 보냄.
    
3. 시간이 지나 Access Token이 만료되면, 서버는 401(Unauthorized) 에러를 반환함.
    
4. 클라이언트는 이를 감지하고, 보관해 둔 Refresh Token을 서버로 보내 새로운 Access Token을 요청함 (Silent Refresh).
    
5. 새 Access Token을 발급받으면, 실패했던 원래 API 요청을 자동으로 재시도함.


# 만료처리(Expiration)

- **서버 측:** 페이로드에 포함된 `exp` (Expiration Time) 클레임을 확인하여 처리함. API 요청이 들어올 때마다 서명을 먼저 검증한 후, `exp` 값이 현재 시간보다 과거인지 체크하여 만료 여부를 판단한다.
    
- **클라이언트 측:** Access Token이 만료되어 401 에러가 발생할 때마다 사용자를 로그아웃시키면 UX가 매우 나빠짐. 따라서 프론트엔드의 HTTP 클라이언트(예: Axios)에서 인터셉터(Interceptor) 기능을 활용해, 401 에러 발생 시 백그라운드에서 조용히 토큰을 갱신하고 요청을 이어가도록 처리하는 것이 필수적이다.


# 저장위치의 보안 트레이드오프

| **저장 위치**             | **특징 및 장점**                                        | **단점 및 보안 취약점**                                                                                           |
| --------------------- | -------------------------------------------------- | --------------------------------------------------------------------------------------------------------- |
| **Local Storage**     | 자바스크립트로 접근이 쉬워 구현이 매우 편함.                          | **XSS(크로스 사이트 스크립팅) 공격에 치명적.** 악성 스크립트가 로컬 스토리지를 열어 토큰을 그대로 훔쳐갈 수 있음.                                     |
| **Cookie (HttpOnly)** | `HttpOnly` 옵션을 켜면 자바스크립트로 접근할 수 없어 XSS 공격을 원천 차단함. | **CSRF(크로스 사이트 요청 위조) 공격에 취약.** 브라우저가 특정 도메인으로 요청 시 알아서 쿠키를 실어 보내기 때문에, 해커가 사용자를 조종해 강제로 요청을 보내게 만들 수 있음. |

**하이브리드 아키텍처:**

1. **Access Token:** 자바스크립트의 **메모리(로컬 변수, 전역 상태 등)**에 저장함. XSS 공격으로 털리기 어렵고 쿠키가 아니라서 CSRF도 피할 수 있음. (단, 새로고침 시 날아감)
    
2. **Refresh Token:** **`HttpOnly`와 `SameSite` 옵션이 적용된 쿠키**에 저장함. 자바스크립트 접근을 막고(XSS 방어), 타 도메인에서의 자동 전송을 막음(CSRF 방어).
    
3. **조합:** 새로고침 시 메모리의 Access Token이 날아가면, 안전한 쿠키에 담긴 Refresh Token을 통해 서버에서 새 Access Token을 발급받아 다시 메모리에 올림.


# JWT 심화 및 보안 전략

기본적인 JWT의 구조와 흐름 외에, 실제 상용 서비스에서 보안과 안정성을 높이기 위해 추가로 적용하는 기법들이다.

### 1. 클레임(Claim) 설계 및 검증 심화

단순히 만료 시간(`exp`)만 확인하는 것을 넘어, 토큰의 출처와 대상을 명확히 검증해야 한다.

- **추가 검증 필드:** `iss`(발급자), `aud`(대상), `jti`(토큰 고유 ID)를 확인하여 위변조 및 잘못된 접근을 차단함.
    
- **Clock Skew(시간 오차) 허용:** 서버 간의 시간 차이를 고려해 `exp` 검증 시 보통 수 초~수십 초의 여유(leeway)를 둠.
    
- **권한(Role) 부여의 딜레마:** 토큰 페이로드에 권한을 넣으면 DB 조회 없이 빠른 인가가 가능하지만, 권한이 변경(예: 관리자 → 일반 유저 강등)되었을 때 토큰이 만료될 때까지 변경 사항이 즉시 반영되지 않는 단점이 있음.
    
- **PII 최소화 및 토큰 경량화:** 페이로드는 누구나 디코딩할 수 있으므로 개인정보(PII)는 절대 넣지 않으며, 네트워크 비용과 헤더/쿠키 용량 제한(약 4KB)을 고려해 필수 식별자만 넣어 토큰 크기를 최소화해야 함.
    

### 2. 서명 알고리즘 및 키(Key) 관리

- **대칭키(HS256) vs 비대칭키(RS256/ES256):** * 단일 서버라면 대칭키로 충분하나, 검증 주체가 여러 서버/외부 서비스로 넓어지면 비대칭키(개인키로 서명, 공개키로 검증)를 사용하는 것이 키 유출 피해를 줄일 수 있어 안전함.
    
- **키 로테이션(Key Rotation):** 서명키 유출에 대비해 주기적으로 키를 교체해야 하며, 토큰 헤더의 `kid`(Key ID)를 통해 어떤 키로 서명되었는지 식별함.
    

### 3. Refresh Token 실전 보안 (Rotation & Revoke)

- **Refresh Token Rotation (회전):** Refresh Token으로 새로운 Access Token을 발급받을 때, 새로운 Refresh Token도 함께 발급하고 기존 것은 즉시 폐기함.
    
- **Reuse Detection (재사용 탐지):** 이미 폐기된 Refresh Token으로 갱신 요청이 들어오면 '토큰 탈취'로 간주하고, 해당 유저의 모든 연결(세션)을 즉시 강제 로그아웃(Revoke) 처리함.
    
- **DB 저장 및 만료 정책:**
    
    - **해시 저장:** DB 유출 시 탈취를 막기 위해 Refresh Token 원문 대신 해시(Hash) 값을 저장함.
        
    - **메타데이터 관리:** 로그인한 기기의 `device_id`, `user_agent`, `ip` 등을 함께 저장하여 "다른 기기에서 모두 로그아웃" 기능이나 이상 탐지에 활용함.
        
    - **2단 만료 정책:** 접속할 때마다 수명을 연장해 주는 `Sliding(자동 연장)`과, 아무리 연장되어도 최초 로그인으로부터 일정 기간이 지나면 무조건 만료시키는 `Absolute Max(최대 수명)`를 함께 적용함.
        

### 4. 강제 로그아웃 및 Stateless의 한계 극복

- Access Token은 한 번 발급되면 원칙적으로 서버가 즉시 무효화할 수 없음.
    
- 따라서 Access Token의 수명은 최대한 짧게(15~30분) 설정하고, 로그아웃이나 권한 박탈이 필요할 때는 **DB에 저장된 Refresh Token을 삭제(Revoke)**하여 추가 갱신을 막는 방식으로 통제함.
    
- 즉시 무효화가 반드시 필요한 경우, `jti` 기반의 Denylist(블랙리스트)를 캐시(Redis 등)에 운용하기도 함.
    

### 5. 저장 및 전송 레이어 보안 (Cookie & CSRF)

- **쿠키(Cookie)의 4중 잠금:** Refresh Token을 쿠키에 담을 때는 `Secure`(HTTPS 전용), `HttpOnly`(XSS 방어), `SameSite`(CSRF 방어), `Path/Domain` 설정을 세트로 적용해야 함.
    
- **CSRF 추가 방어:** 프론트엔드와 백엔드의 도메인이 달라 `SameSite=None`을 써야 하는 경우, CORS 제한, Origin/Referer 검증, Double Submit Cookie 등의 추가 방어책이 필수적임.
    
- **BFF (Backend For Frontend) 패턴:** SPA 환경에서 토큰 탈취를 원천 차단하기 위해, 프론트엔드는 세션 ID만 가지고 중간 비서 서버(BFF)가 실제 JWT 토큰을 관리하는 구조도 많이 사용됨.
    
- **모바일/앱 스토리지:** OS 레벨에서 제공하는 강력한 보안 저장소(iOS Keychain, Android Keystore)에 토큰을 저장하는 것이 표준임.
    

### 6. 프론트엔드 처리: Refresh Storm 방지 및 에러 분기

- **Refresh Storm 방어 (Mutex/Queue):** Access Token 만료 시 여러 API 요청이 동시에 401 에러를 맞고 동시다발적으로 갱신 요청을 보내는 현상(Refresh 폭주). 프론트엔드에서 '대표 요청 하나만 갱신을 시도하고 나머지는 대기(Queue)하는 로직'을 구현해야 함.
    
- **에러 코드 분기:**
    
    - `401 Unauthorized`: 토큰 만료/인증 실패 → 토큰 갱신 시도 또는 로그인 페이지로 이동.
        
    - `403 Forbidden`: 인증은 되었으나 해당 리소스에 접근 권한 없음 → "권한 없음" 안내 띄우기 및 뒤로 가기.
        
- **Refresh 엔드포인트 보호:** 공격자의 무차별 요청을 막기 위해 Rate Limit(요청 횟수 제한)을 걸어야 함.
    

### 7. 보안 관제 (Monitoring & SRE)

- **감사 로그(Audit Log):** 로그인 성공, 토큰 갱신, 재사용 탐지, 권한 박탈(Revoke) 등의 중요 이벤트를 로그로 남겨 사후 추적에 대비함.
    
- **이상 징후 탐지:** 짧은 시간 내에 여러 국가의 IP에서 접속하거나 브라우저(User-Agent)가 급변하는 패턴을 감지하여 토큰을 강제 무효화하는 시스템을 고려함.
    

### 8. OAuth2 / OIDC 와의 관계

- **JWT는 데이터의 '형식(Format)'**일 뿐이다. (플라스틱 신분증)
    
- 실무에서는 토큰을 어떻게 안전하게 발급하고, 권한을 위임하며, 사용자를 인증할 것인지에 대한 **표준 규약(Protocol)인 `OAuth2` (인가)와 `OIDC` (인증)** 모델을 기반으로 JWT를 활용하고 아키텍처를 설계한다.