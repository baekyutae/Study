
### 1. Message Broker (RabbitMQ/Redis) 계층

브로커는 시스템의 심장이므로 여기가 멈추면 전체 파이프라인이 마비된다.

#### 1) 장애 유형

- **브로커 다운(SPOF):** 단일 노드로 운영 중 장비 고장이나 프로세스 크래시 발생 시 전체 중단.
    
- **메시지 유실:** 메모리 기반(Redis) 사용 시 전원 차단으로 인한 큐 데이터 증발.
    
- **Backpressure(배압) 실패:** 워커 처리 속도보다 유입 속도가 압도적으로 빨라 큐가 터지거나 메모리 부족(OOM) 발생.

#### 2) **예방책 & 트레이드오프**

**1) 클러스터링 (High Availability)**

- **예방책:** 단일 노드 실패에 대비해 최소 3대 이상의 노드로 클러스터를 구성하거나 Sentinel(Redis)을 도입해 고가용성을 확보한다.
    
- **트레이드오프 (복잡도 vs 비용):** 인프라 비용이 3배로 증가하고 운영 및 유지보수 난이도가 급격히 상승한다. 초기 단계 서비스에는 과도한 엔지니어링일 수 있다.
    

**2) 메시지 영속성 (Persistence)**

- **예방책:** 메모리 휘발성에 대비해 Redis AOF/RDB나 RabbitMQ Durable Queue 설정을 켜서 메시지를 디스크에 기록한다.
    
- **트레이드오프 (성능 vs 안정성):** 디스크 I/O가 발생하여 전체 처리량(Throughput)이 감소한다. 초고속 처리가 핵심인 경우 병목이 될 수 있다.
    

**3) TTL 및 Max Length 설정**

- **예방책:** 큐가 무한정 커져서 브로커 전체가 OOM(Out of Memory)으로 죽는 것을 막기 위해 메시지 수명이나 큐 길이를 제한한다.
    
- **트레이드오프 (유실 vs 생존):** 큐가 꽉 차면 신규 요청을 거부(Drop)해야 하므로 사용자 요청이 실패 처리된다.


### 2. Worker (Media, AI, Index) 계층


#### 1) 장애 유형

- **Poison Pill (독성 메시지):** 특정 포맷의 영상이나 오디오가 들어오면 무조건 에러를 뱉고, 재시도해도 계속 실패하여 무한 루프 발생.
    
- **Zombie Process:** FFmpeg나 AI 모델 프로세스가 종료되지 않고 메모리만 점유한 채 멈춤(Hang).
    
- **멱등성 위반:** 재시도(Retry) 과정에서 동일한 데이터를 중복 저장하거나, 이미 처리된 과금을 이중 부과.


#### 2) **예방책 & 트레이드오프**


**1) Poison Pill (독성 메시지) : Dead Letter Queue (DLQ)**

- **예방책:** 수차례 재시도해도 실패하는 '독성 메시지(Poison Pill)'는 별도 큐로 격리하여 무한 루프를 방지한다.
    
- **트레이드오프 (운영 리소스):** 격리된 메시지는 자동으로 처리되지 않는다. 개발자가 원인을 분석하고 수동으로 재처리(Replay)하거나 폐기하는 운영 비용이 발생한다.
    

**2) Zombie Process : Liveness Probe & Timeout**

- **예방책:** 워커가 일정 시간 응답이 없으면(Zombie Process) 강제로 종료하고 재시작시킨다.
    
- **트레이드오프 (작업 낭비):** 단순히 긴 영상 처리에 시간이 오래 걸리는 정상적인 상황이었음에도 타임아웃으로 강제 종료될 수 있다. 이 경우 처리했던 자원이 낭비된다.


**3) 멱등성 (Idempotency)**

- **예방책:** 워커가 작업을 시작하기 전 DB 상태를 체크(`if task.status == 'DONE'`)하여 중복 실행을 막는다.
    
- **트레이드오프 (개발 복잡도 & 부하):** 모든 비즈니스 로직에 상태 체크 코드를 삽입해야 하며, 잦은 상태 확인 쿼리가 DB에 추가 부하를 준다.


### 3. External Dependency (AI Service)

#### 1) 장애 유형

- **API 할당량 초과(Rate Limit)로 요청 거부.**
    
- **연쇄 장애 및 무한 대기**: 외부 서비스가 응답을 늦게 주거나 아예 죽었을 때, 내 워커 스레드가 응답을 기다리다(Blocking) 고갈되어 시스템 전체가 멈추는 현상.

- **재시도 폭주 (Thundering Herd)**: 장애 복구 직후 대기하던 워커들이 동시에 API를 호출하여 다시 장애를 유발.


#### 2) **예방책 & 트레이드오프**

**1) API 할당량 초과Rate Limit (429 Error) : Token Bucket (Rate Limiter)**

- **예방책:** Redis 등을 이용해 분당 호출 횟수(RPM)를 엄격히 제한하여 쿼터 초과 에러(429)를 방지한다.
    
- **트레이드오프 (처리량 제한):** 외부 API 쿼터가 남아있더라도 내부 설정값에 의해 처리 속도가 인위적으로 제한될 수 있다(Resource Under-utilization).
    

**2)  연쇄 장애 및 무한 대기** : Circuit Breaker & Timeout

- **예방책:** 
	- **Timeout (1차):** 일정 시간(예: 10초) 응답이 없으면 즉시 연결을 끊는다.
    
	- **Circuit Breaker (2차):** 연속으로 에러가 발생하면 일정 시간 동안 외부 호출을 아예 차단(Open)하여 즉시 실패 처리한다
    
- **트레이드오프 (가용성):** 
	- 차단된 시간 동안은 정상적인 요청조차 시도되지 않고 실패 처리된다.
    
	- 단순히 처리 시간이 긴 작업(긴 영상)이었음에도 타임아웃으로 강제 종료되어, 그때까지 쓴 자원이 낭비될 수 있다.



**3) 재시도 폭주 (Thundering Herd) : Exponential Backoff & Jitter**

- **예방책:** 
	- 실패 시 즉시 재시도하지 않고, 대기 시간을 지수적으로 늘린다(1초, 2초, 4초...).
    
	- 여기에 랜덤 시간(Jitter)을 섞어 워커들의 요청 시점을 분산시킨다.
    
- **트레이드오프 (Latency):** 최대 재시도 횟수나 대기 시간이 길어질수록, 사용자 입장에서 최종 결과를 받아보는 시간(End-to-End Latency)이 늘어난다.


# 나중에 검토


---

## 1. 계층별 설계 검토 및 보완점

### **1.1 Message Broker 계층**

- **긍정적 평가**: SPOF 방지를 위한 클러스터링과 메시지 유실 방지를 위한 Persistence 설정을 정확히 짚었습니다.
    
- **시니어의 조언 (보완)**:
    
    - **Quorum/Split-brain**: 클러스터링 시 노드 간 상태 불일치(Split-brain)를 방지하기 위한 'Quorum(의결 정족수)' 개념을 추가하면 좋습니다.
        
    - **Producer Confirm**: 브로커가 메시지를 디스크에 썼는지 Producer(API 서버)에게 알려주는 'Publisher Confirms' 설정도 영속성 보장을 위해 함께 고려되어야 합니다.
        

### **1.2 Worker 계층**

- **긍정적 평가**: DLQ(Dead Letter Queue) 도입과 멱등성(Idempotency)의 중요성을 강조한 부분이 매우 훌륭합니다.
    
- **시니어의 조언 (보완)**:
    
    - **Pre-signed URL 만료 문제**: `biblio` 프로젝트는 비디오를 다룹니다. 재시도(Retry)가 길어질 경우, 초기에 생성한 Pre-signed URL이 만료되어 Worker가 파일에 접근하지 못할 수 있습니다. 이를 위해 **'만료 전 갱신 로직'**이나 **'Worker 전용 내부 권한'**에 대한 고려가 필요합니다.
        
    - **Graceful Shutdown**: 워커 프로세스가 업데이트 등으로 종료될 때, 현재 처리 중인 작업을 안전하게 마무리하고 ACK를 보내지 않은 채 종료하는 '우아한 종료' 로직이 필수입니다.
        

### **1.3 External Dependency (AI Service)**

- **긍정적 평가**: Exponential Backoff와 Circuit Breaker는 분산 시스템의 기본이면서도 가장 놓치기 쉬운 부분인데 잘 반영되었습니다.
    
- **시니어의 조언 (보완)**:
    
    - **Fallback 전략**: Circuit Breaker가 Open 되었을 때(외부 API 사용 불가 시), 사용자에게 "현재 분석이 지연되고 있습니다"라는 메시지를 보여주거나, 핵심 기능만이라도 동작하게 하는(예: 단순 업로드 완료 처리) **Degradation(단계적 기능 축소)** 전략을 고민해 보세요.
        

---

## 2. 추가로 고려해야 할 핵심 이슈

문서에는 누락되었으나 실무에서 반드시 발생하는 문제들입니다.

### **A. Dual Write 문제 (데이터 정합성)**

`Index Worker`가 Main DB와 Vector DB 두 곳에 데이터를 저장할 때 발생하는 문제입니다.

- **장애 상황**: Main DB에는 저장됐는데 Vector DB 저장 시 에러가 나면?
    
- **대응책**: 트랜잭션 내에서 처리하거나, 실패 시 다시 큐에 넣는 로직을 정교하게 설계해야 합니다. (문서의 'Index Worker' 세부 내용에 추가 권장)
    

### **B. 리소스 격리 (Resource Isolation)**

- 비디오 처리(Media Worker)는 CPU를, AI 응답 대기(AI Worker)는 I/O를 많이 사용합니다.
    
- 이 두 작업이 같은 서버 자원을 공유하면 서로 간섭할 수 있으므로, **컨테이너(Docker/K8s) 단위로 CPU/Memory 할당량을 격리**하는 설정을 운영 단계에서 고려해야 합니다.
    

### **C. 모니터링 지표의 구체화**

- 단순히 'Queue Depth'를 보는 것을 넘어, **'메시지 소비 지연 시간(Consumer Lag)'**을 핵심 지표로 관리해야 합니다.
    
    - _Lag이 5분 이상이면 Auto-scaling 트리거 가동_ 같은 구체적인 운영 정책이 필요합니다.
        

---
