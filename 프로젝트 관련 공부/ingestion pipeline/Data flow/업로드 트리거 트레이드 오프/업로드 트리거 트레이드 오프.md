

`Biblio`와 같은 대용량 업로드 시스템에서 가능한 **4가지 핵심 트리거 패턴**을 브레인스토밍 해드리고, 각각의 치명적인 장단점을 분석해 드립니다.

---

### Option 1. Storage Event Trigger 

스토리지(AWS S3, GCS)가 "파일 들어왔음"이라고 이벤트를 쏘는 방식입니다.

- **흐름:** 업로드 완료 $\rightarrow$ 스토리지(S3)가 감지 $\rightarrow$ SQS/PubSub으로 자동 알림 발송 $\rightarrow$ Worker 소비
    
- **장점:**
    
    - **완벽한 비동기:** API 서버가 죽어 있어도 트리거는 발생합니다.
        
    - **구현 간소화:** "업로드 완료 API"를 따로 만들 필요가 없습니다.
        
- **치명적인 단점 (Context Missing):**
    
    - **메타데이터 부재:** S3가 보내주는 이벤트 메시지에는 `Key(파일명)`와 `Size`만 있고, **이걸 누가 올렸는지(`user_id`), 어떤 프로젝트인지(`project_id`) 정보가 없습니다.**
        
    - **해결책 강제:** 결국 파일명에 정보를 쑤셔 넣거나(`user123_project456_video.mp4`), 워커가 DB를 다시 조회해서 주인을 찾아야 하는 번거로움이 생깁니다.
        

### Option 2. API Server Explicit Trigger 

클라이언트가 업로드를 마치고 서버에게 **"나 다 올렸어(Upload Complete)"**라고 보고하면, API 서버가 큐에 작업을 넣는 방식입니다.

- **흐름:**
    
    1. Client: Presigned URL로 업로드 수행.
        
    2. Client: API 서버의 `/api/videos/{id}/complete` 호출.
        
    3. API Server: 파일이 진짜 있는지 확인(HeadObject) 후, **메타데이터를 포함하여** 큐에 메시지 발행 (`Publisher` 역할).
        
- **장점:**
    
    - **풍부한 컨텍스트:** API 서버는 세션 정보를 알기 때문에, 큐에 메시지를 넣을 때 `{ "file_key": "...", "user_id": 101, "plan": "premium" }` 처럼 **작업에 필요한 모든 정보**를 담아줄 수 있습니다. 워커가 DB를 조회할 일이 줄어듭니다.
        
    - **흐름 제어:** 유저의 등급에 따라 우선순위 큐(Priority Queue)로 분기하거나, 업로드 직후 바로 유효성 검사를 하여 에러를 반환하기 좋습니다.
        
- **단점:**
    
    - **신뢰성 의존:** 클라이언트가 업로드는 성공했는데, 인터넷이 끊겨서 `/complete` 요청을 못 보내면? 서버는 영원히 업로드된 줄 모르는 **Zombie File**이 생깁니다. (배치로 청소 필요)
        

### Option 3. Serverless Function (FaaS) (절충안)

스토리지 이벤트와 서버 로직의 장점을 섞은 방식입니다.

- **흐름:** 업로드 완료 $\rightarrow$ S3 이벤트 $\rightarrow$ **AWS Lambda / Google Cloud Functions 실행** $\rightarrow$ Lambda가 DB에서 메타데이터 조회 및 검증 $\rightarrow$ Queue에 적재
    
- **장점:**
    
    - 인프라 트리거(Option 1)의 자동화를 유지하면서, 중간에 로직(Option 2)을 끼워 넣을 수 있습니다.
        
    - API 서버 부하를 전혀 주지 않습니다.
        
- **단점:**
    
    - **관리 포인트 증가:** 관리해야 할 FaaS(Function as a Service) 코드가 하나 늘어납니다.
        
    - **Cold Start:** 람다의 초기 구동 지연이 있을 수 있습니다 (비디오 처리에선 큰 문제 아님).
        
    - **DB 부하:** 람다가 갑자기 1000개 뜨면 DB 커넥션 풀을 고갈시킬 수 있습니다.
        

### Option 4. Polling (비추천)

서버나 별도 스케줄러가 주구장창 스토리지를 감시하는 방식입니다.

- **흐름:** Cron Job이 1분마다 버킷 목록 조회(`ListObjects`) $\rightarrow$ 새로운 파일 발견 시 처리
    
- **장점:**
    
    - 아키텍처가 매우 단순함. 큐나 브로커 설정이 귀찮을 때 씀.
        
- **단점:**
    
    - **실시간성 최악:** 운 나쁘면 59초 뒤에 처리가 시작됩니다.
        
    - **비용 낭비:** 파일이 없어도 계속 API를 호출하므로 비용이 발생합니다.
        
    - **상태 관리 복잡:** "이거 처리한 파일인가?"를 판단하기 위해 별도의 마킹이 필요합니다.
        

---

### ⚖️ 비교 및 선택 가이드 (Trade-off Matrix)

|**기준**|**Option 1. Storage Event (기존)**|**Option 2. API Server Trigger (추천)**|**Option 3. Serverless Fn**|
|---|---|---|---|
|**실시간성**|최상 (즉시)|상 (네트워크 1홉 추가)|최상|
|**구현 난이도**|하 (설정만 하면 됨)|중 (API 개발 필요)|중상 (FaaS 관리)|
|**정보 전달력**|**최하** (파일명만 전달)|**최상** (모든 정보 전달 가능)|중 (DB 조회 필요)|
|**좀비 파일 위험**|없음|있음 (클라이언트 실패 시)|없음|
|**결합도**|낮음 (Loose Coupling)|중간 (API가 큐를 알아야 함)|낮음|



---
## 2차 고민

1. API Server Trigger
클라이언트가 업로드 완료 후, 서버에게 직접 "완료 API"를 호출하여 큐에 작업을 할당받는 방식.

장점

메타데이터 동기화 용이: 완료 요청 시 필요한 메타 데이터를 함께 전송할 수 있어 데이터 매칭이 수월함.

즉각적인 피드백: 클라이언트 입장에서 서버가 업로드를 확인했고, 전처리 작업을 시작했다는 사실을 응답(Response)으로 즉시 확인 가능.

단점

신뢰성 및 좀비 파일 문제: 업로드는 성공했으나 인터넷 끊김이나 페이지 닫기 등으로 클라이언트가 "완료 API"를 호출하지 못하면, 서버는 업로드 사실을 영영 모르게 됨. (전처리 미실행)

해결책: Garbage Collector를 이용해 Pending 상태로 24시간 지난 파일을 삭제하는 배치 작업 필요.

보안 및 검증 비용: 클라이언트가 업로드도 안 하고 "완료 API"만 호출하는 악의적 공격이 가능함.

해결책: 서버가 실제로 스토리지에 파일이 존재하는지, 용량은 맞는지 확인하는 요청(Head Object)을 추가로 날려야 함.

2. Serverless Function Middleware
스토리지 업로드 이벤트가 발생하면 람다 함수(Serverless)가 자동으로 실행되어 브로커와 중개하는 방식.

장점

높은 신뢰성 (보장성): 클라이언트의 상태(페이지 종료, 인터넷 끊김)와 무관하게, 스토리지에 파일이 들어오면 무조건 함수가 실행됨. 따라서 파일은 있는데 후속 처리가 안 되는 누락 사고 가능성이 매우 낮음.

단점

클라이언트 확인의 어려움 (UX): 클라이언트는 내 파일이 서버에서 정상적으로 접수되었는지 즉시 알 방법이 없음.

해결책: API 서버가 DB 상태를 조회하는 API(Polling)를 제공하거나, WebSocket을 연결해 별도로 알려줘야 함.

인프라 종속성: 스토리지의 이벤트 트리거 기능이 특정 클라우드 벤더(AWS, GCP 등)에 종속되는 경향이 있음.

해결책: 의존성 주입(DI)과 헥사고날 아키텍처(어댑터 패턴)를 적용하여 비즈니스 로직과 인프라 코드를 분리함으로써 해결 가능.




3. Storage Upload Trigger (Pure)
스토리지 자체의 이벤트 기능을 사용하되, 별도의 미들웨어 없이 바로 워커나 서버로 이벤트를 전달하는 방식.

장점

독립적 실행: API 서버의 상태(서버 다운 등)와 상관없이 스토리지가 알아서 트리거를 발생시키므로 실행이 보장됨.

구현 용이성: 별도의 복잡한 아키텍처 없이 스토리지 설정만으로 가능하여 상대적으로 구현 난이도가 낮음.

단점

메타데이터 전달의 한계: 업로드 시 영상에 대한 메타데이터(제목, 작성자 등)를 이벤트 객체에 같이 실어 보내기 어려움.

결과: 추후 워커(Worker)에서 작업 시, 어떤 파일인지 식별하기 위해 DB를 따로 조회하고 매칭하는 번거로운 절차가 필요함.

상태 동기화 로직 분산: 클라이언트가 업로드 완료를 확인할 방법이 없고, DB의 영상 상태를 '업로드 완료'로 전환하는 로직도 파편화되어 별도로 구현해야 함.

4. API Server Polling
API 서버가 스토리지에 파일이 올라왔는지 계속해서 주기적으로 확인(Polling)하는 방식.

단점 (장점 없음)

리소스 비효율성: 서버가 업로드 여부를 확인하기 위해 지속적으로 요청을 보내며 자원을 점유해야 하므로 매우 비효율적임.

아키텍처 부적합: 현대적인 웹 서버 아키텍처가 지향하는 무상태성(Stateless)을 보장하기에 적합하지 않음. (불필요한 연결 유지 및 상태 확인 부하 발생)


---

## 1,2 상세 비교

| **비교 항목**  | **1. API Server Trigger (클라이언트 주도)** | **2. Serverless Middleware (인프라 주도)** |
| ---------- | ------------------------------------ | ------------------------------------- |
| **핵심 가치**  | **개발 편의성, 빠른 UX**                    | **높은 신뢰성, 서버 보호**                     |
| **트리거 주체** | 클라이언트 (Frontend)                     | 스토리지 (AWS S3, GCP GCS)                |
| **신뢰성**    | **낮음** (클라이언트 이탈 시 누락 발생)            | **높음** (파일만 있으면 무조건 실행)               |
| **보안**     | **취약** (검증 로직 필수 구현)                 | **안전** (물리적 파일 생성 시만 작동)              |
| **UX 복잡도** | **낮음** (API 응답으로 즉시 처리)              | **높음** (Polling/Socket 등 별도 구현 필요)    |
| **인프라 종속** | 없음 (표준 HTTP API)                     | 있음 (클라우드 벤더별 설정 필요)                   |
1번(API Server Trigger)과 2번(Serverless Function Middleware)은 **"누가 후속 처리의 방아쇠를 당기느냐"**에 따라 명확하게 장단점이 갈립니다.

결국 **'구현 편의성 및 즉각적인 피드백(1번)'**이냐, **'데이터 무결성 및 시스템 안정성(2번)'**이냐의 싸움입니다.

비교 요약표와 상세 내용을 정리해 드립니다.

---

### **비교 요약표**

|**비교 항목**|**1. API Server Trigger (클라이언트 주도)**|**2. Serverless Middleware (인프라 주도)**|
|---|---|---|
|**핵심 가치**|**개발 편의성, 빠른 UX**|**높은 신뢰성, 서버 보호**|
|**트리거 주체**|클라이언트 (Frontend)|스토리지 (AWS S3, GCP GCS)|
|**신뢰성**|**낮음** (클라이언트 이탈 시 누락 발생)|**높음** (파일만 있으면 무조건 실행)|
|**보안**|**취약** (검증 로직 필수 구현)|**안전** (물리적 파일 생성 시만 작동)|
|**UX 복잡도**|**낮음** (API 응답으로 즉시 처리)|**높음** (Polling/Socket 등 별도 구현 필요)|
|**인프라 종속**|없음 (표준 HTTP API)|있음 (클라우드 벤더별 설정 필요)|

---

### **상세 비교: 장단점 분석**

#### **1. API Server Trigger (직접 호출)**

> _"나 다 올렸어! 처리해줘!"라고 클라이언트가 서버를 부르는 방식_

**장점 (Why Option 1?)**

- **구현이 직관적이다:** 평소에 만드는 REST API와 똑같습니다. 인프라 설정을 건드릴 필요 없이 코드만 짜면 됩니다.
    
- **사용자 피드백이 빠르다:** 업로드가 끝나고 API 요청이 성공하면(200 OK), 그 즉시 화면에 "처리 시작됨"을 띄울 수 있습니다. 복잡한 비동기 상태 관리가 필요 없습니다.
    
- **메타데이터 처리가 쉽다:** API 요청 바디(Body)에 제목, 설명, 태그 등을 같이 보내면 되므로 DB 저장 로직이 단순합니다.
    

**단점 (Risk)**

- **신뢰성 구멍 (좀비 파일):** 사용자가 업로드 직후 와이파이가 끊기거나 브라우저를 닫으면, 스토리지에 파일은 있는데 서버는 모르는 상황이 발생합니다. (별도 청소 로직 필요)
    
- **보안 검증 비용:** 악의적인 유저가 거짓으로 "업로드 완료" API를 쏠 수 있습니다. 이를 막기 위해 서버는 스토리지에 `HEAD Object` 요청을 보내 파일 유무와 크기를 검증하는 로직을 필수로 짜야 합니다.
    

#### **2. Serverless Function Middleware (람다 중개)**

> _"파일이 들어왔네? 내가 처리하고 보고할게."라고 인프라가 알아서 움직이는 방식_

**장점 (Why Option 2?)**

- **완벽한 처리 보장:** 클라이언트의 상태와 상관없이, 스토리지에 파일이 착륙하는 순간 람다가 납치(?)해서 후속 작업을 진행합니다. 누락될 확률이 거의 없습니다.
    
- **서버 부하 분산:** 갑자기 1만 명이 업로드를 해도 람다가 알아서 스케일링(확장)하여 처리하므로, 메인 API 서버는 전혀 영향을 받지 않습니다.
    
- **보안성:** 실제로 파일이 생성되어야만 이벤트가 발생하므로, 거짓 요청 자체가 불가능합니다.
    

**단점 (Risk)**

- **UX 구현 난이도 상승:** 클라이언트는 업로드가 끝난 후 "서버가 이걸 확인했나?"를 바로 알 수 없습니다.
    
    - 따라서 프론트엔드에서 주기적으로 확인(Polling)하거나, 웹소켓을 연결하는 등 추가적인 구현이 강제됩니다.
        
- **개발/테스트 환경의 복잡함:** 로컬 환경에서 S3 이벤트를 똑같이 재현하며 테스트하기가 까다롭습니다. AWS/GCP 콘솔 설정이 필요하며 인프라에 의존적인 코드가 될 수 있습니다(DI로 완화 가능).
    

---

### **최종 조언 (Senior's Feedback)**

**"Biblio" 프로젝트의 성격(포트폴리오, 학습용, 고품질 지향)을 고려할 때 저의 추천은:**

> **2번 (Serverless Middleware) 방식을 채택하십시오.**

1. **백엔드 엔지니어로서의 어필:** 단순히 "기능이 돌아간다"를 넘어 **"결함 내성(Fault Tolerance)이 있는 아키텍처를 설계했다"**는 점을 강조하기 좋습니다.
    
2. **보안/검증 비용 절감:** 1번 방식에서 필수적인 `HEAD Object` 검증 로직을 짤 필요 없이, 아키텍처 구조 자체로 신뢰성을 확보하는 세련된 방식입니다.
    
3. **UX 단점 극복:** UX 문제는 "업로드 완료! (처리가 곧 시작됩니다)" 정도의 낙관적 UI(Optimistic UI)로 타협하거나, 간단한 Polling으로 충분히 해결 가능합니다.