
이 설계 패턴의 정식 명칭은 **의존성 역전 원칙 (Dependency Inversion Principle)** 과 **어댑터 패턴 (Adapter Pattern)** 의 조합입니다.

`요약`
상위 수준의 비즈니스 로직이 하위 수준의 기술 스택(Vertex AI, PostgreSQL 등)에 직접 의존하지 않도록, **인터페이스(추상 클래스)**를 두어 그 관계를 느슨하게 결합(Loose Coupling)시켰습니다

=> 의존성 역전의 원칙 

---

### 1. 핵심 원리 (Theory)

이 구조의 핵심은 **"중간에 통역사(Interface)를 세우는 것"**입니다.

- **기존 방식 (강한 결합):** 비즈니스 로직이 특정 SDK(AWS boto3)를 직접 붙잡고 있습니다. SDK가 바뀌면 비즈니스 로직도 무너집니다.
    
- **추상화 방식 (느슨한 결합):** 비즈니스 로직은 "인터페이스"만 바라봅니다. 실제 SDK는 인터페이스 뒤에 숨겨져 있습니다.
    

이 구조를 3단계 계층(Layer)으로 나누어 보겠습니다.

1. **Service Layer (사장님):** 비즈니스 로직. "업로드 URL을 달라"고 명령만 함.
    
2. **Interface Layer (주문서):** "URL을 주려면 이런 함수 이름을 써야 한다"는 규칙(계약).
    
3. **Infrastructure Layer (직원):** 실제 AWS, GCS SDK를 사용하는 구체적인 코드.
    

---

### 2. 코드 레벨 구현 (Practice)

Python 코드로 4단계에 걸쳐 구현해 보겠습니다.

#### 단계 1: 인터페이스 정의 (계약서 작성)

가장 먼저, 모든 스토리지들이 지켜야 할 **공통 규칙**을 만듭니다.



``` python
from abc import ABC, abstractmethod

class StorageInterface(ABC):
    """
    모든 스토리지 어댑터는 이 클래스를 상속받아야 한다.
    (AWS든 GCS든 이 함수는 무조건 가지고 있어야 함)
    """
    @abstractmethod
    def generate_presigned_url(self, file_name: str, content_type: str) -> str:
        pass
```

#### 단계 2: 어댑터 구현 (직원 채용)

이제 인터페이스 규격에 맞춰 실제 SDK를 사용하는 코드를 작성합니다.

**A. AWS S3용 어댑터**



```Python
import boto3

class S3StorageAdapter(StorageInterface):
    def __init__(self, bucket_name):
        self.s3 = boto3.client('s3')
        self.bucket = bucket_name

    def generate_presigned_url(self, file_name: str, content_type: str) -> str:
        # AWS SDK의 고유 문법 사용
        return self.s3.generate_presigned_url(
            'put_object',
            Params={
                'Bucket': self.bucket, 
                'Key': file_name, 
                'ContentType': content_type
            },
            ExpiresIn=300
        )
```

**B. GCS(Google Cloud)용 어댑터** (나중에 추가됨)


``` Python
from google.cloud import storage

class GCSStorageAdapter(StorageInterface):
    def __init__(self, bucket_name):
        self.client = storage.Client()
        self.bucket = self.client.bucket(bucket_name)

    def generate_presigned_url(self, file_name: str, content_type: str) -> str:
        # 구글 SDK의 고유 문법 사용 (AWS랑 다름)
        blob = self.bucket.blob(file_name)
        return blob.generate_signed_url(
            version="v4", 
            expiration=300, 
            method="PUT", 
            content_type=content_type
        )
```

#### 단계 3: 비즈니스 로직 작성 (사장님 업무)

서비스 코드는 구체적인 어댑터(`S3StorageAdapter` 등)를 모릅니다. 오직 `StorageInterface`만 믿고 코드를 짭니다.



```Python
class VideoService:
    # 핵심: 생성자에서 '구체적인 직원'을 주입받음 (Dependency Injection)
    def __init__(self, storage: StorageInterface):
        self.storage = storage

    def prepare_video_upload(self, user_id: str, file_name: str, mime_type: str):
        # 1. 파일명 안전하게 변경 (비즈니스 로직)
        safe_name = f"videos/{user_id}/{file_name}"
        
        # 2. 인터페이스를 통해 URL 요청
        # (self.storage가 AWS인지 구글인지 몰라도 됨)
        upload_url = self.storage.generate_presigned_url(safe_name, mime_type)
        
        return {"upload_url": upload_url}
```

#### 단계 4: 조립 및 실행 (Dependency Injection)

애플리케이션이 시작되는 곳(`main.py` 등)에서 **어떤 스토리지를 쓸지 결정**해서 넣어줍니다.



```Python
# [설정] 오늘은 AWS를 쓰자!
current_storage = S3StorageAdapter(bucket_name="my-aws-bucket")

# [주입] 서비스에 AWS 직원을 넣어줌
service = VideoService(storage=current_storage)

# [실행]
print(service.prepare_video_upload("user1", "intro.mp4", "video/mp4"))
```

---

### 3. 만약 GCS로 바꿔야 한다면?

위의 코드 중 **`단계 4`만 수정**하면 됩니다.

Python

```
# [설정 변경] AWS 버리고 구글 쓰자!
# current_storage = S3StorageAdapter(...)  <-- 삭제
current_storage = GCSStorageAdapter(bucket_name="my-google-bucket") # <-- 추가

# [주입] 서비스 코드는 수정할 필요 없음 (그대로 사용)
service = VideoService(storage=current_storage)

# [실행] 똑같이 실행됨
print(service.prepare_video_upload("user1", "intro.mp4", "video/mp4"))
```

### 4. 최종 요약

이 패턴(추상화)을 사용했을 때 얻는 이점은 다음과 같습니다.

1. **교체 용이성:** `VideoService` 코드 수정 없이 스토리지 백엔드를 AWS $\leftrightarrow$ GCS $\leftrightarrow$ 자체서버로 자유롭게 바꿀 수 있습니다.
    
2. **테스트 용이성:** 테스트할 때 실제 AWS에 연결하지 않고, 가짜 URL만 뱉어주는 `MockStorageAdapter`를 끼워 넣어 빠르게 테스트할 수 있습니다.
    
3. **코드 깔끔함:** 비즈니스 로직(`VideoService`)에서 지저분한 SDK 설정 코드들이 싹 사라집니다.
    

이 구조는 백엔드 개발자 면접이나 포트폴리오 설명에서 **"유지보수성과 확장성을 고려한 설계"**로 어필하기 아주 좋은 포인트입니다.


# 의존성 역전의 원칙


"역전(Inversion)"이라고 부르는 이유는 **"소스 코드의 의존 방향(화살표)이 반대"**가 되기 때문입니다.

누가 누구에게 의존하는지(누가 '갑'이고 누가 '을'인지)로 설명해 드릴게요.

---

### 1. 원래대로라면 (순방향: 비즈니스 로직이 '을')

보통 코드를 짜면, 상위 모듈(비즈니스 로직)이 하위 모듈(구체적인 도구)을 가져다 씁니다.

- **상황:** `IngestionWorker`(상위)가 `VertexAI`(하위)를 직접 import 해서 씁니다.
    
- **관계:** "VertexAI님, 제가 님을 써야 하니까 님의 사용법(메서드 이름 등)에 제가 맞출게요."
    
- **화살표:** `IngestionWorker` ➔ `VertexAI`
    
- **문제점:** `VertexAI`가 업데이트되거나 `Whisper`로 바뀌면, 나(`IngestionWorker`)도 내 코드를 다 뜯어고쳐야 합니다. **(내가 도구에 휘둘림)**
    

### 2. 의존성 역전 (역방향: 비즈니스 로직이 '갑')

여기서 인터페이스(`STTService`)가 등장합니다. 중요한 건 **이 인터페이스를 누가 정의하느냐**입니다. 바로 **비즈니스 로직** 쪽에서 정의합니다.

- **선언:** `IngestionWorker`: "나는 구글이든 뭐든 모르겠고, `transcribe`라는 기능이 있는 녀석이 필요해. 이게 내 규칙(Interface)이야."
    
- **구현:** `VertexAIAdapter`: "넵, 제가 그 `STTService` 규칙에 맞춰서 구현하겠습니다."
    
- **화살표:**
    
    - `IngestionWorker` ➔ `STTService` (인터페이스)
        
    - `VertexAIAdapter` ➔ `STTService` (인터페이스)
        
- **결과:** 화살표 방향을 보세요. 아까는 워커가 Vertex를 가리켰는데, 이제는 **Vertex(구현체)가 워커 쪽의 인터페이스를 바라보고(의존하고) 있습니다.**
    

> **도구(인프라)가 비즈니스 로직의 규칙(인터페이스)에 의존하게 되었다.**
> 
> ➔ 의존의 방향이 **역전**되었다!

---

### 3. 쉬운 비유: "콘센트와 가전제품"

이걸 이해하면 제일 빠릅니다.

- **비즈니스 로직(집 주인):** 벽에 **'220V 구멍 두 개(인터페이스)'**라는 규칙을 정해놨습니다.
    
- **인프라(헤어드라이어, 냉장고, TV):** 이 제품들이 집 주인을 위해 전기를 쓰려면, **자기 플러그를 220V 모양으로 만들어서(구현해서)** 와야 합니다.
    

**누가 누구에게 맞췄나요?**

- 집 주인(로직)이 다이슨 드라이어(인프라)에 맞춰서 벽공사를 다시 했나요? **(순방향 - X)**
    
- 다이슨 드라이어(인프라)가 집의 콘센트 규격(인터페이스)에 맞춰서 플러그를 달고 왔나요? **(역전 - O)**
    

이처럼 **"중요한 비즈니스 로직이 사소한 인프라(도구)에 휘둘리지 않고, 오히려 인프라가 로직이 정한 규격에 맞추게 만드는 것"**, 이것이 바로 의존성 역전(DIP)의 핵심입니다.

### 요약

질문하신 내용에 빗대어 수정해 드리자면:

> "비즈니스 로직이 특정 인프라를 가져오는 게 아니라, **비즈니스 로직은 '규칙(인터페이스)'만 정해두고, 인프라가 그 규칙을 따르게(의존하게) 만드는 것**"

