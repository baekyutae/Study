
# 놓치고 있던 점

사람 A,B가 무게1 무게3 반대로 무게 3 무게 1 드는 경우 중복으로 처리되어 조합상 1개임

때문에 낮은 무게 부터 조합을 만들어 나갈때 무게 1,3 이 나왔다면 3, 1은 제외

즉 낮은 순으로 정렬하여 A가 든 무게 보다 무거운 무게의 볼링공만 B가 들어야함

# 문제 아이디어

```python
    array = [0] * 11
    
    for x in Ball_weight:
        array[x] += 1

```

와 같이 배열을 만들고 인덱스를 무게처럼 활용

array[1]은 무게가 1인 볼링공의 개수

```python
for i in range(1, m+1):
        n -= array[i] # 들고있는 무게의 공 갯수 제외
        result += array[i] * n
```
무게 별로 순환 하면서 더 무거운 공과의 조합을 result에 더해주고 반환

# 시간복잡도

for x in Ball_weight: array[x] += 1 여기서 시간복잡도 n 발생 

그리고 

    for i in range(1, m+1):
        n -= array[i] # 들고있는 무게의 공 갯수 제외
        result += array[i] * n

여기서 무게 m만큼 각 무게별 경우의 수 계산 들어가니 시간복잡도 m 발생

마지막으로

array = [0] * (m + 1)

에서 m 발생

빅오 표기법에 따라 시간복잡도 O(n+m)

# 유닛 테스트

```python

cases = [
    # m,n, 볼링공 무게, 예상결과

    # 1. 모두 같은 무게
    (5, 3, [3,3,3,3,3], 0),

    # 2. 하나만 다른 무게
    (5, 3, [1,1,1,1,3], 4),

    # 3. 공이 하나
    (1, 3, [2], 0),

    # 4. 모두 다른 무게
    (4, 4, [1,2,3,4], 6),

    # 5. 일반 섞인 케이스
    (5, 3, [1,3,2,3,2], 8),

    # 6. 중간 무게 없는 케이스
    (4, 5, [1,1,4,5], 5),

    # 7. m=1 극단 케이스
    (4, 1, [1,1,1,1], 0),

    # 8. n < m, 일부 무게 0개
    (3, 5, [2,5,5], 2),
]
```