# 아이디어

혼자서 풀떈 1초 단위로 회전판을 순회하는 방식을 고안 했는데

"가장 양이 적은 음식"을 기준으로, 남은 모든 음식의 높이를 한꺼번에 깎아버리는 방식이 정답이였다.

남은 모든 음식의 높이를 한꺼번에 깎아버리는 방식:

[8,6,4] 섭취 시간 배열이 이렇다면 가장 적은 3번음식을 다 먹어치우려면 총 4번의 순회가 필요함

음식갯수(3) * 섭취시간(4) = 12

또한 순회한 것이기 때문에 그과정에서 다른음식도 4초만큼 섭취 다시말해 깎임

```python
while sum_value + ((q[0][0]-previous)*length) <= k:

```

에서 (q[0][0]-previous)*length 를 하는 이유이다


## 전체 로직은 아래와 같다

### 1. 예외 처리 (조기 종료)

```python
if sum(food_times) <= k:
        return -1
```
만약 모든 음식 시간의 합 <= k라면?

방송 사고가 터지기도 전에 이미 식사가 끝나버린 상황이므로 -1을 리턴하고 끝낸다.

### 2. 우선순위 큐(Heap) 초기화

모든 음식을 (음식 시간, 원래 번호) 형태로 힙에 넣는다.

=>  이때, 힙은 **음식 시간(양이 적은 순)**으로 자동 정렬

### 3. 핵심 루프: 통째로 시간 삭제하기 

변수 정의:

now: 현재 힙의 맨 위에 있는 가장 적은 음식의 시간.

previous: 지난 라운드까지 깎아낸 높이 (누적).

length: 현재 남은 음식의 개수.

while문 판단 (If):

음식을 다 먹어치우는 시간 (now - previous) * length 이 현재 남은 시간 (k - sum_value) 보다 작거나 같다면?

실행 (Then):

```python
now = heapq.heappop(q)[0]
```

음식들중 먹는데 가장 짧게 걸리는 음식의 시간 정의

```python
sum_value += (now-previous)*length 
```

음식을 다먹어 치우는데 걸리는 시간을 구해 sum_value에 누적 후 heappop()으로 해당 음식을 테이블에서 제거.

```python
length -= 1
previous = now
```
음식이 하나 줄어들고, previous를 현재 now로 갱신

이 과정을 시간이 부족해질 때까지 반복

### 4. 방송 에러 이후 먹을 음식 번호 찾기

```python
result = sorted(q, key = lambda x: x[1])
    return result[(k-sum_value)%length][1]
```

원래 음식 번호 순서대로 정렬 후 먹을 음식 번호 리턴

# 시간 복잡도

heappush연산은 O(logN) * 음식갯수 N == O(NlogN)

heappop으로 최솟값을 꺼내고 힙을 재정렬하는 데 걸리는 시간은 O(logN) , 최악의 경우 모든 음식 꺼냄 == O(NlogN)

남은 음식 정렬 == O(NlogN)

빅오(Big-O) 표기법에서는 앞에 붙은 상수는 무시하므로, 최종적으로 **O(NlogN)**