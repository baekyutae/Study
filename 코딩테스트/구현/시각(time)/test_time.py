import pytest



def number_check(h):
    count = 0
    for i in range(0,h+1):
        for m in range(60):
            for s in range(60):
                if '3' in str(i)+str(m)+str(s):
                    count += 1
    return count





# 테스트 코드

test_cases = [
    # CASE 1: 최소 경계값 (0시)
    # 0시 00분 00초 ~ 0시 59분 59초 구간. 
    # 시(Hour)에 3이 없으므로 분/초에 3이 들어가는 경우만 카운트 (1,575개)
    (0, 1575),

    # CASE 2: 단순 누적 (0시 ~ 2시)
    # 0시, 1시, 2시 모두 시(Hour)에 3이 없으므로
    # 1,575 * 3 = 4,725
    (2, 4725),

    # CASE 3: 특이점 경계 (0시 ~ 3시)
    # 3시는 시(Hour) 자체에 3이 포함됨 -> 3시 구간은 3,600초 모두 카운트
    # (0~2시: 1575*3) + (3시: 3600) = 4725 + 3600 = 8325
    (3, 8325),

    # CASE 4: 특이점 이후 누적 (0시 ~ 5시)
    # 3시를 지나 다시 4시, 5시는 1,575개씩 추가됨
    # 8325(3시까지 누적) + 1575(4시) + 1575(5시) = 11,475
    (5, 11475),

    # CASE 5: 두 자리 수 시각 포함 (0시 ~ 13시)
    # 13시도 시(Hour)에 3이 포함되므로 3,600초 통째로 카운트
    # 계산 검증용이라기보다 로직이 13을 '3' 포함으로 잘 인식하는지 확인
    (13, 26100),
    
    # CASE 6: 최대 경계값 (0시 ~ 23시)
    # 하루(0~23시) 전체 카운트
    # 3이 들어가는 시(3, 13, 23시 -> 3개 * 3600) + 나머지(21개 * 1575)
    (23, 43875),
]

@pytest.mark.parametrize("h, expected", test_cases)
def test_number_check(h, expected):
    """
    number_check 함수가 
    '3'이 포함된 시각과 그렇지 않은 시각을 
    구분하여 정확히 누적하는지 검증
    """
    assert number_check(h) == expected

# 결과
# 6 passed in 0.10s