'''
<문제 조건>

# 나눗셈을 하는 함수를 구현하세요.(순환소수 처리 포함)


입력=>출력 예시
5, 3 => 1.(6)
6, 2 => 3
1, 3 => 0.(3)
 1, 7 => 0.(142857)

x,y = 나눌 대상 , 나누는 수 (정수)
() => 순환소수 묶음
순환 소수가 아닌경우 소숫점 네자리까지 표현(다섯번째 자리에서 반올림)

입력값은 0 이상 정수
출력은 문자열
7/12 => 0.58333333 이렇게 반복된다면 0.58(3), 비순환구간+순환구간 허용



<풀이 아이디어>

y가 0인 경우:
나눗셈 성립불가 => y가 0일때: '나눗셈이 불가합니다' 문자열 출력

순환소수 판단조건: 나눴을 때 이미 나온 나머지가 반복해서 나오면 순환소수 시작(같은 나머지를 y로 나누면 또 같은 몫과 나머지가 나옴 => 반복시작)
ex) 1 % 3 하면 나머지로 계속 1 나옴

딕셔너리에 나머지를 저장 {나머지:위치} 

=>매번 같은 나머지가 나오는지 체크, 나오면 중복되는 나머지가 처음 나온 위치 앞에 (를 붙이고 맨마지막에 )를 붙여줌

정수 부분과 소수점 부분을 구하는 방식:
x//y 하면 몫=> 정수 부분이 나옴 7//12 == 0
x%y 하면 나머지 => 소수 부분이 나옴, 이때 나머지에 계속 *10을 해줘야 나머지를 계속 구할 수 있음(나눗셈 손으로 해봄)



반올림해 넷째 자리까지 구하는 방식:

나머지를 x로 계속 나눠주다 순환소수가 아니고 5째 자리가 넘어가면 반복문 종료하고 넷째자리에서 +1 해줌


문제점: 5자리로 제한을두니 0.(142857)과 같은 경우에 대응이 안됨 => 100으로 상한선 늘림 

<의사코드>

def divde_func(x,y):
    if y == 0: # 나눗셈이 불가능한 경우
        return "나눗셈이 불가합니다"
    
    if x%y == 0 면: # 자연수로 나누어 떨이진다면
        return str(x//y)
         

    memo={} 나머지와 나머지의 위치를 기록 하는 딕셔너리
    
    result = ['x//y','.'] 반환할 나머지 결과를 저장하는 리스트
    => result에 미리 정수부분과 소수점 '.' 는 넣어놓음
    
    remain = x%y 첫 나머지 구하기

    while 나머지가 0 이 아니면 반복:
        
        if 같은 나머지가 또 나오면 => 순환소수 시작:
            처음 해당 나머지가 나온 위치 앞에 ( 를
            result 끝에 )를 넣음
            => result에 insert를 써서 ( 를 넣음
            break 
              
        if 소수점 길이가 100이상이면:
            다섯째 자리에서 반올림 한걸 출력

        현재의 나머지와 나머지의 위치를 memo에 저장

        remain *= 10 => 나누기 위해 10 곱함
        소수부분(몫) = reamin // y
        result.apppend(str(소수부분))
        remain %= y
        
return result를 하나의 문자열로 합침 
            
    
'''

def divde_func(x, y):
    if y == 0: return "나눗셈 불가"
    if x % y == 0: return str(x // y)

    memo = {} 
    result = [str(x // y), "."] # 정수부와 점 미리 넣기
    
    remain = x % y # 첫 나머지

    while remain != 0:
        # 순환소수인 경우
        if remain in memo:
            idx = memo[remain]    # 방금전 나머지와 같은 나머지
            result.insert(idx, "(") # 순환소수 표기
            result.append(")")      
            break 

        # 넷째 자리 까지 반올림
        if len(result) - 2 >= 100: 
            return f"{x/y:.4f}" 

        memo[remain] = len(result)


        remain *= 10
        quotient = remain // y
        result.append(str(quotient))
        
        remain %= y  

    return "".join(result)
