

## 메인루틴(Main routine)

* 프로그램의 시작점이며 주 흐름을 담당, 일련의 작업을 수행하고 다른 서브 루틴이나 코루틴을 호출 가능

* 주요 역할

  * **프로그램 시작점**: 프로그램 시작 지점을 정의하고 초기화 작업을 수행
  * **작업 수행**: 프로그램이 수행해야 하는 주요 작업을 정의하고 호출
  * **서브루틴 호출**: 필요에 따라 다른 서브루틴이나 함수를 호출하여 작업을 분할하고 모듈화
    → 이를 통해 코드를 재사용하고 유지보수성을 향상
  * **프로그램 종료**: 모든 주요 작업이 완료된 후 정리 작업을 수행하고, 필요에 따라 리소스를 해제하고 프로그램을 종료

---

## 서브루틴(subroutine)

* 다른 프로그램에서 호출되는 함수

* 서브루틴을 사용하면 비슷한 작업을 수행하는 코드를 여러 곳에서 재사용할 수 있다.
  이로써 코드의 중복을 피하고 유지보수성을 향상시킬 수 있음.

```python
import time

# [서브루틴] 직원: 시키는 일(덧셈)만 하고 결과를 돌려줌
def sub_routine_worker(a, b):
    print(f"    (직원): {a} + {b} 계산 지시를 받았습니다.")
    time.sleep(1)  # 일하는 시간
    result = a + b
    print("    (직원): 계산 완료! 복귀합니다.")
    return result

# [메인루틴] 사장님: 전체 흐름을 주도함
def main_routine_boss():
    print("(사장님): 프로그램 시작! 직원에게 일 지시.")

    # 서브루틴 호출 (Call) - 이때 사장님은 직원이 끝날 때까지 기다림
    worker_result = sub_routine_worker(10, 20)

    print(f"(사장님): 직원이 가져온 결과는 {worker_result}구나.")
    print("(사장님): 프로그램 종료. 퇴근하자!")

# 프로그램의 진입점 (Entry Point)
if __name__ == "__main__":
    main_routine_boss()
```

```text
(사장님): 프로그램 시작! 직원에게 일 지시.
    (직원): 10 + 20 계산 지시를 받았습니다.
    (직원): 계산 완료! 복귀합니다.
(사장님): 직원이 가져온 결과는 30구나.
(사장님): 프로그램 종료. 퇴근하자!
```

---

## 코루틴(Coroutine)

* 메인루틴에서 호출되지만, 코루틴은 실행되는 도중에 일시중단되어 다시 메인루틴으로 전환되었다가
  다시 코루틴으로 전환될 수 있는 **"제어 흐름"이 가능한 루틴**

* 서브루틴과의 차이점

  1. **메모리 구조와 상태 (Memory & State)**

     * **서브루틴**: Call Stack에 종속적.
       호출 시 Stack Frame이 생성되지만, 작업 종료(`return`) 시 Pop되어 사라진다.
       따라서 이전 상태를 기억하지 못하는 Stateless(상태 비보존) 특성을 가진다.
       진입점(Entry Point)은 항상 함수 시작점 하나뿐이다.

     * **코루틴**: Heap 등 별도의 메모리 공간을 이용.
       `yield`로 중단하면 그 시점의 지역 변수와 Instruction Pointer(실행 위치)를 저장해둔다.
       이후 `resume` 요청 시 저장된 상태를 복원하여 멈췄던 위치(새로운 진입점)에서 재개하므로
       Stateful(상태 보존) 특성을 가진다.

  2. **제어 흐름 (Control Flow)**

     * **서브루틴 (Blocking)**: 메인루틴이 `Call`하면 제어권이 완전히 넘어간다.
       서브루틴이 `Return`할 때까지 메인루틴은 아무것도 하지 못하고 대기(Blocking)하게 된다.

     * **코루틴 (Cooperative / Non-blocking)**:
       메인루틴과 코루틴이 제어권을 핑퐁처럼 주고받는다.
       코루틴이 스스로 `yield`하여 제어권을 양보하고,
       메인루틴이 다시 `resume`하는 과정을 반복하게 되는데
       이 빠른 전환을 통해 싱글 스레드에서도 여러 작업이 동시에 수행되는 듯한
       동시성(Concurrency)을 가진다.

### 코루틴 예제

```python
import time

# [코루틴] 라면 주방장
def ramyeon_chef():
    print("[주방장] 출근. 대기합니다. (Start)")
    total_dishes = 0  # [상태 보존] 누적 요리 수

    while True:
        # yield에서 대기, send()로 받은 값은 menu에 저장
        menu = (yield)

        if menu == "마감":
            print("[주방장] 퇴근합니다. (Exit)")
            break

        # 조리 시작 (Resume)
        total_dishes += 1
        print(f"    [주방장] '{menu}' 조리 중... (누적: {total_dishes})")
        time.sleep(1)
        print(f"    [주방장] '{menu}' 완성.")

# [메인루틴] 홀 매니저
if __name__ == "__main__":
    print("[매니저] 영업 시작.")

    # 1. 코루틴 객체 생성
    chef = ramyeon_chef()

    # 2. 코루틴 시작 (첫 yield까지 실행)
    next(chef)

    print("[매니저] 주문 접수.")

    # 3. 데이터 전송 (Main -> Coroutine)
    chef.send("신라면")
    print("[매니저] 식사 중...\n")
    time.sleep(2)

    # 4. 데이터 추가 전송
    chef.send("짜파게티")
    print("[매니저] 정리 중...\n")

    # 5. 종료 신호
    try:
        chef.send("마감")
    except StopIteration:
        print("[매니저] 영업 종료.")
```

```text
[매니저] 영업 시작.
[주방장] 출근. 대기합니다. (Start)
[매니저] 주문 접수.
    [주방장] '신라면' 조리 중... (누적: 1)
    [주방장] '신라면' 완성.
[매니저] 식사 중...

    [주방장] '짜파게티' 조리 중... (누적: 2)
    [주방장] '짜파게티' 완성.
[매니저] 정리 중...

[주방장] 퇴근합니다. (Exit)
[매니저] 영업 종료.
```

---

## 코루틴 객체

`chef = ramyeon_chef()` 와 같이 코루틴 함수를 실행했을 때 코루틴 객체가 생성된다.
그럼 코루틴 객체가 뭘까?

1. **코루틴 객체**

   * 코루틴 함수(`def`)를 호출했을 때 반환되는 실제 실행 단위(Instance)이자 데이터 컨테이너

2. **내부 구조**

   * **독립된 스택 프레임**:
     객체 내부에 자신만의 전용 메모리 공간을 가져
     지역 변수나 상태 값을 외부와 격리하여 저장
   * **인스트럭션 포인터 (Instruction Pointer)**:
     코드의 어디까지 실행했는지, 다음에는 어디서부터 시작해야 하는지(Context)를 기억하는
     **책갈피**를 내장

3. **주요 특성 (Characteristics)**

   * **독립성 (Independence)**:
     같은 코루틴 함수로 여러 개의 객체를 생성하더라도,
     각 객체는 서로 다른 메모리 공간을 쓰기 때문에 서로의 상태에 전혀 영향을 주지 않는다.

   * **일회성 (One-off)**:
     한 번 실행이 완료되어 종료(`return` 또는 `StopIteration`)된 객체는 다시 사용할 수 없고,
     재실행하려면 **새로운 객체를 다시 생성**해야 한다.

---

* 추가 정리

## 1. 콜 스택 (Call Stack): "할 일의 탑"

**콜 스택**은 프로그램이
"지금 어디까지 실행했지?"를 기억하는 메모리 공간.

자료구조의 스택(Stack)과 똑같이 **LIFO (Last-In, First-Out: 후입선출)** 방식으로 작동함.

### 🍽️ 비유: 접시 쌓기

1. **Main 함수**가 실행되면 바닥에 접시를 하나 깐다.
2. Main이 **함수 A**를 부르면, 그 위에 접시 A를 쌓는다. (Push)
3. 함수 A가 **함수 B**를 부르면, 접시 A 위에 접시 B를 쌓는다. (Push)
4. 함수 B가 끝나면?
   **맨 위의 접시 B를 치워버린다.** (Pop) → 다시 A가 맨 위가 됨.

---

## 2. 스택 프레임 (Stack Frame): "접시 하나"

**스택 프레임**은 콜 스택에 쌓이는 **접시 하나하나**를 의미한다.
함수가 호출될 때마다 딱 그 함수만을 위한 전용 메모리 공간(접시)이 한 장씩 발급됨.

이 메모장(접시)에는 딱 3가지가 적혀 있음:

1. **복귀 주소 (Return Address)**

   * "나 끝나면 어디로 돌아가야 하지?"
   * 예: 함수 A의 15번째 줄로 돌아가시오.

2. **매개변수 (Parameters)**

   * 함수를 부를 때 넘겨받은 재료들
   * 예: `a = 10`, `b = 20`

3. **지역 변수 (Local Variables)**

   * 함수 안에서만 쓰고 버릴 임시 데이터들
   * 예: `total`, `temp_result`


