
## 메인루틴(Main routine)

- 프로그램의 시작점 이며 주 흐름을 담당, 일련의 작업을 수행하고 다른 서브 루틴이나 코루틴을 호출 가능 

- 주요 역할
	- 프로그램 시작점: 프로그램 시작지점을 정의하고 초기화 작업을 수행
	
	- 작업 수행: 프로그램이 수행해야하는 주요 작업을 정의하고 호출
	
	- 서브루틴 호출: 필요에 따라 다른 서브루틴이나 함수를 호출하여 작업을 분할하고 모듈화. 이를 통해 코드를 재사용하고 유지보수성을 향상
	
	- 프로그램 종료: 모든 주요 작업이 완료된 후 정리 작업을 수행하고, 필요에 따라 리소스를 해제하고 프로그램을 종료


## 서브루틴(subroutine)

- 다른 프로그램에서 호출되는 함수

- 서브루틴을 사용하면 비슷한 작업을 수행하는 코드를 여러 곳에서 재사용할 수 있다. 이로써 코드의 중복을 피하고 유지보수성을 향상시킬 수 있음.


```python
import time

# [서브루틴] 직원: 시키는 일(덧셈)만 하고 결과를 돌려줌

def sub_routine_worker(a, b):

    print(f"    (직원): {a} + {b} 계산 지시를 받았습니다.")

    time.sleep(1) # 일하는 시간

    result = a + b

    print("    (직원): 계산 완료! 복귀합니다.")

    return result

# [메인루틴] 사장님: 전체 흐름을 주도함

def main_routine_boss():

    print("(사장님): 프로그램 시작! 직원에게 일 지시.")

    # 서브루틴 호출 (Call) - 이때 사장님은 직원이 끝날 때까지 기다림

    worker_result = sub_routine_worker(10, 20)

    print(f"(사장님): 직원이 가져온 결과는 {worker_result}구나.")

    print("(사장님): 프로그램 종료. 퇴근하자!")

  
# 프로그램의 진입점 (Entry Point)

if __name__ == "__main__":

    main_routine_boss()
    
    
    
# 실행결과
# (사장님): 프로그램 시작! 직원에게 일 지시.
#    (직원): 10 + 20 계산 지시를 받았습니다.
#    (직원): 계산 완료! 복귀합니다.
# (사장님): 직원이 가져온 결과는 30구나.
# (사장님): 프로그램 종료. 퇴근하자!    
```




## 코루틴(Coroutine)

- 메인루틴에서 호출되지만, 코루틴은 실행되는 도중에, 일시중단되어 다시 메인루틴으로 전환되었다가 다시 코루틴으러 전환될 수 있는 "제어흐름"이 가능한 루틴

- 서브루틴과의 차이점

	1. 메모리 구조와 상태 (Memory & State)
	
	- 서브루틴: Call Stack에 종속적. 호출 시 Stack Frame이 생성되지만, 작업 종료(Return) 시 Pop되어 사라진다. 따라서 이전 상태를 기억하지 못하는 Stateless(상태 비보존) 특성을 가진다. 진입점(Entry Point)은 항상 함수 시작점 하나뿐이다.
    
	- 코루틴: Heap 등 별도의 메모리 공간을 이용. `yield`로 중단하면 그 시점의 지역 변수와 Instruction Pointer(실행 위치)를 저장해둔다. 이후 `resume` 요청 시 저장된 상태를 복원하여 멈췄던 위치(새로운 진입점)에서 재개하므로 Stateful(상태 보존) 특성을 가진다.

	2. 제어 흐름 (Control Flow)

	- 서브루틴 (Blocking): 메인루틴이 `Call`하면 제어권이 완전히 넘어간다. 서브루틴이 `Return`할 때까지 메인루틴은 아무것도 하지 못하고 대기(Blocking)하게 된다.
    
	- 코루틴 (Cooperative / Non-blocking): 메인루틴과 코루틴이 제어권을 핑퐁처럼 주고받는다. 코루틴이 스스로 `Yield`하여 제어권을 양보하고, 메인루틴이 다시 `Resume`하는 과정을 반복하게 되는데 이 빠른 전환을 통해 싱글 스레드에서도 여러 작업이 동시에 수행되는 듯한 동시성(Concurrency)을 가진다.


\+ 추가 정리

## 1. 콜 스택 (Call Stack): "할 일의 탑"

**콜 스택**은 프로그램이 "지금 어디까지 실행했지?"를 기억하는 메모리 공간. 자료구조의 스택(Stack)과 똑같이 LIFO (Last-In, First-Out: 후입선출) 방식으로 작동함

#### 🍽️ 비유: 접시 쌓기

1. **Main 함수**가 실행되면 바닥에 접시를 하나 깐다.
    
2. Main이 **함수 A**를 부르면, 그 위에 접시 A를 쌓는다. (Push)
    
3. 함수 A가 **함수 B**를 부르면, 접시 A 위에 접시 B를 쌓는다. (Push)
    
4. 함수 B가 끝나면? **맨 위의 접시 B를 치워버린다.** (Pop) -> 다시 A가 맨 위가 됨.


## 2. 스택 프레임 (Stack Frame): "접시 하나"

**스택 프레임**은 콜 스택에 쌓이는 **접시 하나하나**를 의미한다. 함수가 호출될 때마다 딱 그 함수만을 위한 전용 메모리 공간(접시)이 한 장씩 발급됨.

이 메모장(접시)에는 딱 3가지가 적혀 있음:

1. **복귀 주소 (Return Address)**:
    
    - "나 끝나면 어디로 돌아가야 하지?"
        
    - (예: 함수 A의 15번째 줄로 돌아가시오.)
        
2. **매개변수 (Parameters)**:
    
    - 함수를 부를 때 넘겨받은 재료들.
        
    - (예: `a=10`, `b=20`)
        
3. **지역 변수 (Local Variables)**:
    
    - 함수 안에서만 쓰고 버릴 임시 데이터들.
        
    - (예: `total`, `temp_result`)