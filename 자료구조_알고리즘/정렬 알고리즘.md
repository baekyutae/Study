
정렬: 데이터를 특정한 기준에 따라서 순서대로 나열

- 선택정렬
- 삽입정렬
- 퀵정렬
# 1. 선택 정렬

매번 가장 작은 것을 선택한다.

선택된 가장 작은 요소를 맨앞의 요소와 자리를 바꿈

정렬된 가장 작은 요소를 제외한 그다음으로 제일 작은 요소를 찾아 앞에서 두번째 요소와 교체

위 과정을 정렬이 완료 될때 까지 반복 (n-1번)


```python

array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)): # 맨 앞에서 부터 가장 작은 요소와 교체
	min_index = i # 가장 작은 원소의 인덱스
	for j in range(i+1,len(array)):
		if array[min_index] > array[j]: # 가장 작은 요소 탐색
			min_index = j
	array[i], array[min_index] = array[min_index], array[i]
	
print(array)
```

```plaintext
[0,1,2,3,4,5,6,7,8,9]
```

### **시간복잡도** : O(N^2)


 💡 선택 정렬 시간 복잡도 증명

전체 $n$번의 라운드가 진행되면서, 각 라운드마다 **이미 정렬된 개수($x$)를 뺀 나머지 원소들을 비교해야 한다. 이때 $x$는 0부터 시작해 1씩 증가

- **1단계 ($x=0$):** 정렬된 원소 없음 $\rightarrow$ $(n-1)$번 비교
    
- **2단계 ($x=1$):** 1개 정렬됨 $\rightarrow$ $(n-2)$번 비교
    
- **3단계 ($x=2$):** 2개 정렬됨 $\rightarrow$ $(n-3)$번 비교
    
- ...
    
- **마지막 단계:** 1개만 남음 $\rightarrow$ $1$번 비교
    

이 비교 횟수를 모두 더하면 1부터 $n-1$까지의 합인 **등차수열의 합**이 된다

$$\text{총 비교 횟수} = (n-1) + (n-2) + \dots + 2 + 1 = \sum_{i=1}^{n-1} i$$

등차수열의 합 공식($\frac{n(n+1)}{2}$)을 적용하면:

$$= \frac{n(n-1)}{2}$$

 
식 전개와 빅오($O$) 도출

위의 공식을 전개하여 빅오 표기법의 규칙(가장 차수가 높은 항만 남기고 상수는 무시)을 적용

1. **식 전개:**
    
    $$\frac{n(n-1)}{2} = \frac{n^2 - n}{2} = \frac{1}{2}n^2 - \frac{1}{2}n$$
    
2. **빅오 표기법 적용:**
    
    - 최고차항 선택: $n$이 무한대로 커질 때 $n^2$이 $n$보다 압도적인 영향을 미치므로, 차수가 낮은 $-\frac{1}{2}n$ 항은 무시
        
        $$\rightarrow \frac{1}{2}n^2$$
        
    - 상수(계수) 제거: 실행 시간의 증가율(Trend)을 보는 것이므로 앞의 계수 $\frac{1}{2}$은 생략.
        
        $$\rightarrow n^2$$
        

### 3. 결론


$$O(n^2)$$


시간복잡도가 n^2 이라 숫자가 조금만 커져도 실행시간이 급격히 늘어나므로 추후 설명할 다른 정렬방식에 비해 비효율적임

-----

# 2. 삽입 정렬

데이터를 적절한 위치에 삽입하는 방식, 데이터가 적절한 위치에 들어가기 이전에 그 앞까지의 데이터는 이미 정렬되어 있다고 가정

필요할 때만 위치를 바꾸는 방식이라 데이터가 거의 정렬 되어 있을 때 효율적이다.

삽입 정렬은 두번째 데이터 부터 시작, 첫번째는 그 자체로 정렬되어 있다고 판단

```python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(1, len(array)):
	for j in range(i,0,-1):
		if array[j] < array[j-1]:
			array[j], array[j-1] = array[j-1],array[j]
		else:
			break
		
print(array)
```

- 초기: `[7] 5, 9, 0 ...`
    
- $i=1$: `[5, 7] 9, 0 ...` (5 삽입)
    
- $i=2$: `[5, 7, 9] 0 ...` (9는 제자리)
    
- $i=3$: `[0, 5, 7, 9] 3 ...` (0이 맨 앞으로 이동)
    
- ... (반복) ...
    
- 최종: `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`

삽입한 원소들은 이미 정렬되어 있음


### **시간복잡도** : O(N^2)

선택 정렬과 마찬가지로 반복문이 2번 중첩 되어 사용
리스트가 거의 정렬되어 있는 경우 빠르게 동작 => 중첩 for문에서 안쪽 for문이 대부분 한번만 비교(이미 정렬 됨)하고 break로 빠짐

-----

# 3. 퀵 정렬

기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의  위치를 바꿈

퀵정렬엔 pivot이 사용, 큰 숫자와 작은 숫자를 교화 할때 교환 기준으 된다.

pivot을 설정하고 리스트를 분할하는 방법에 따라서 퀵정렬을 구분하는데 여기선 대표적인 방식인 호어 분할방식으로 설명

호어 분할방식: 리스트에서 첫번째 데이터를 pivot으로 설정

왼쪽에서 부터 pivot보다 큰 데이터를 찾고 오른쪽에서 부터 피벗보다 작은 데이터를 찾는다. 그 다음 데이터의 위치를 서로 교환을 반복

<예시>

 배열 [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

(보통 맨 앞에 있는 숫자를 기준(Pivot)으로 잡는 방식이 가장 이해하기 쉬우니, 이 방법으로 설명하겠습니다.)

---

### [1단계] 첫 번째 분할 (전체)

- **현재 배열:** `[5, 7, 9, 0, 3, 1, 6, 2, 4, 8]`
    
- **기준(Pivot):** **`5`** (맨 앞 숫자)
    
- **목표:** `5`보다 **작은 건 왼쪽**, **큰 건 오른쪽**으로 보냅니다.
    

**과정:**

1. 왼쪽부터 `5`보다 큰 숫자를 찾습니다. $\rightarrow$ **`7`** 발견!
    
2. 오른쪽부터 `5`보다 작은 숫자를 찾습니다. $\rightarrow$ **`4`** 발견!
    
3. 둘을 바꿉니다. (`7` $\leftrightarrow$ `4`)
    
    - 결과: `[5, 4, 9, 0, 3, 1, 6, 2, 7, 8]`
        
4. 다시 왼쪽부터 큰 수 찾기 $\rightarrow$ **`9`** 발견!
    
5. 오른쪽부터 작은 수 찾기 $\rightarrow$ **`2`** 발견!
    
6. 둘을 바꿉니다. (`9` $\leftrightarrow$ `2`)
    
    - 결과: `[5, 4, 2, 0, 3, 1, 6, 9, 7, 8]`
        
7. 다시 왼쪽부터 큰 수 찾기 $\rightarrow$ **`6`** 발견!
    
8. 오른쪽부터 작은 수 찾기 $\rightarrow$ **`1`** 발견!
    
    - **어?** 왼쪽에서 오는 애(`6`)와 오른쪽에서 오는 애(`1`)가 서로 **지나쳐버렸습니다(교차)**. (탐색 위치가 엇갈림)
        
9. 이렇게 엇갈리면, **작은 숫자(`1`)**와 **기준(`5`)**의 자리를 바꿉니다.
    
    - **최종 교환:** `5` $\leftrightarrow$ `1`
        

1단계 결과:

[1, 4, 2, 0, 3] 5 [6, 9, 7, 8]

> 해설: 기준이었던 5는 이제 자기 자리를 완벽하게 찾았습니다!
> 
> 5 왼쪽은 모두 5보다 작고, 오른쪽은 모두 5보다 큽니다.

---

### [2단계] 왼쪽 동네 정렬하기 (`[1, 4, 2, 0, 3]`)

이제 5의 왼쪽 부분만 봅니다.

- **현재 배열:** `[1, 4, 2, 0, 3]`
    
- **기준(Pivot):** **`1`**
    

**과정:**

1. 왼쪽부터 `1`보다 큰 수 $\rightarrow$ **`4`**
    
2. 오른쪽부터 `1`보다 작은 수 $\rightarrow$ **`0`**
    
3. 엇갈리지 않았으니 교환! (`4` $\leftrightarrow$ `0`)
    
    - 결과: `[1, 0, 2, 4, 3]`
        
4. 다시 탐색... 어? 탐색 위치가 서로 엇갈립니다. (`0` 위치에서 만남)
    
5. 작은 숫자(`0`)와 기준(`1`)을 바꿉니다.
    

2단계 결과:

[0] 1 [2, 4, 3]

> **해설:** **1**도 자기 자리를 찾았습니다. 왼쪽엔 `0`, 오른쪽엔 `2, 4, 3`이 남았습니다. `0`은 혼자 남았으니 정렬 끝!

---

### [3단계] 1의 오른쪽 동네 (`[2, 4, 3]`) 정렬

- **현재 배열:** `[2, 4, 3]`
    
- **기준(Pivot):** **`2`**
    

**과정:**

1. 왼쪽에서 `2`보다 큰 수 $\rightarrow$ **`4`**
    
2. 오른쪽에서 `2`보다 작은 수 $\rightarrow$ **없음(자기 자신인 2)**. (탐색 위치가 엇갈림)
    
3. 엇갈린 지점의 작은 수(자기 자신 `2`)와 기준(`2`)을 바꿉니다 (제자리).
    

3단계 결과:

[] 2 [4, 3]

> **해설:** **2** 정렬 완료. 오른쪽 `[4, 3]`만 남았습니다.

---

### [4단계] 2의 오른쪽 동네 (`[4, 3]`) 정렬

- **현재 배열:** `[4, 3]`
    
- **기준(Pivot):** **`4`**
    

**과정:**

1. 엇갈림 발생 $\rightarrow$ 작은 수 `3`과 기준 `4`를 바꿉니다.
    

4단계 결과:

[3] 4 []

> **해설:** **4** 정렬 완료. `3`은 혼자 남았으니 자동 정렬.

---

### [5단계] 아까 맨 처음에 남겨둔 5의 오른쪽 동네 (`[6, 9, 7, 8]`)

이제 반대편 큰 숫자 동네로 갑니다.

- **현재 배열:** `[6, 9, 7, 8]`
    
- **기준(Pivot):** **`6`**
    

**과정:**

1. 왼쪽에서 `6`보다 큰 수 $\rightarrow$ **`9`**
    
2. 오른쪽에서 `6`보다 작은 수 $\rightarrow$ **없음(6)**. (바로 엇갈림)
    
3. 기준(`6`)과 작은 수(`6`) 교환 (제자리).
    

5단계 결과:

[] 6 [9, 7, 8]

> **해설:** **6** 정렬 완료.

---

### [6단계] 6의 오른쪽 동네 (`[9, 7, 8]`)

- **현재 배열:** `[9, 7, 8]`
    
- **기준(Pivot):** **`9`**
    

**과정:**

1. 왼쪽 큰 수 $\rightarrow$ 없음
    
2. 오른쪽 작은 수 $\rightarrow$ `8`
    
3. 엇갈림 $\rightarrow$ 기준(`9`)과 작은 수(`8`) 교환.
    

6단계 결과:

[8, 7] 9 []

---

### [7단계] 9의 왼쪽 동네 (`[8, 7]`)

- **현재 배열:** `[8, 7]`
    
- **기준(Pivot):** **`8`**
    

**과정:**

1. 엇갈림 $\rightarrow$ 기준(`8`)과 작은 수(`7`) 교환.
    

7단계 결과:

[7] 8 []

---

### 🎉 최종 합체

이 모든 과정이 끝나면 조각났던 배열들이 순서대로 합쳐집니다.

`0` `1` `2` `3` `4` **5** `6` `7` `8` `9`

### 핵심 요약

1. **반장(Pivot을 하나 뽑습니다.
    
2. 반장보다 **작으면 왼쪽**, **크면 오른쪽**으로 줄을 세웁니다.
    
3. 나눠진 왼쪽 반, 오른쪽 반에서 **다시 반장을 뽑고 2번을 반복**합니다. (이걸 '재귀'라고 해요)

4. 엇갈림이 발생하면 항상 pivot과 작은 수의 위치를 교환
    
5. 혼자 남을 때까지 계속하면 정렬 끝!


### 코드로 구현

```python
array = [5,7,9,0,3,1,6,2,4,8]

def quick_sort(array, start, end):
	if start >= end:
		return
	pivot = start
	left = start + 1
	right = end
	
	while left <= right:
		# left <= end 와 right > start : 각각 왼쪽 오른쪽으로 이동하다 start와 end를 벗어나지 않게 하기 위함
		while left <= end and array[left] <= array[pivot]:
			left += 1
		while right > start and array[right] >= array[pivot]:
			right -= 1
			
		if left > right:
			array[right],array[pivot] = array[pivot], array[right]
		else:
			array[left],array[right] = array[right], array[left]
				
	quick_sort(array, start, right-1)
	quick_sort(array, right+1, end)
```


### 시간복잡도 : O(NlogN)

1. 배열을 절반씩 나눠 1개가 될때 까지 반복하는 횟수 logN
ex) 8을 절반씩 나눠서 1개가 되려면 3번 반으로 나눠야 함 log8 = 3 (밑이 2)
8 => (1) 4 4 => (2) 2  2  2  2 => (3) 1 1 1 1 1 1 1 1

2. 반으로 나눌때 마다 매번 모든 원소에 대해 pivot 보다 큰지 작은지 확인하는 횟수 N

매번 나눌때 마다 n개의 원소에 대해 크기 비교를 하니 n * logn


+ N이 이해가 안가서 보충 설명

**상황: 100명의 승객이 입국 심사를 받습니다**

**1. [1층] 전체 심사 (100명)**

- **상황:** 비행기에서 내린 100명($N$)이 한 줄로 섰습니다.
    
- **피봇(심사관 A):** "자, 여권 보여주세요. 저보다 나이 적으면 왼쪽, 많으면 오른쪽으로 가세요."
    
- **검사:** 100명 **모두** 심사관 A 앞에 서서 여권을 보여줘야 합니다.
    
- **결과:** 왼쪽 방에 50명, 오른쪽 방에 50명으로 나뉩니다.
    

> **검사 횟수:** 100번

2. [2층] 조별 심사 (50명 + 50명)

이제 방이 두 개로 나뉘었지만, 정렬이 끝난 게 아닙니다. 각 방에도 심사관이 새로 배치됩니다.

- **왼쪽 방 (50명):** 심사관 B(새 피봇)가 서 있습니다.
    
    - 여기 있는 50명은 심사관 B에게 여권을 다시 보여주고 비교해야 합니다. (**50번 검사**)
        
- **오른쪽 방 (50명):** 심사관 C(새 피봇)가 서 있습니다.
    
    - 여기 있는 50명도 심사관 C에게 여권을 보여줘야 합니다. (**50번 검사**)
        
- **합계:** 50 + 50 = **100번**
    

> **핵심:** 방이 쪼개졌다고 해서 승객이 집으로 간 게 아닙니다. **모든 승객은 각자의 방에서 '또' 검사를 받아야 합니다.**

3. [3층] 분단별 심사 (25명 + 25명 + 25명 + 25명)

방이 4개로 쪼개졌습니다.

- 각 방마다 25명씩 있고, 각 방의 심사관(피봇)에게 검사를 받습니다.
    
- **합계:** 25 + 25 + 25 + 25 = **100번**
    

---

### 🔍 요약

"검사를 한다"는 건 "피봇이랑 비교하는 `if`문이 실행된다"는 뜻입니다.

1. 데이터가 잘게 쪼개져도, 데이터(승객)의 **총인원수($N$)는 변하지 않습니다.**
    
2. 어느 층(Level)이든 간에, 살아있는 모든 데이터는 **반드시 자기 구역의 피봇과 한 번씩 싸워봐야(비교해봐야)** 자리를 잡을 수 있습니다.
    
3. 그래서 1층에서도 100번, 2층에서도 (다 합쳐서) 100번, 3층에서도 (다 합쳐서) 100번... 이렇게 **매 층마다 $N$번의 비교**가 일어나는 것입니다.