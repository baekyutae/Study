# 기본 개념

Priority Queue

일반 큐의 경우 먼저 온 사람이 먼저 나가는 형태(FIFO)이지만 우선순위큐는 우선순위가 높은 사람 먼저 나가는형태의 자료형이다. (들어온 순서는 무관함)

우선순위큐를 구현하는 방법은 List와 Heap이 있으며 주로 Heap 사용한다

리스트의 경우 꺼낼때 마다 전체를 뒤지거나 정렬(sort)후 꺼내야해 시간복잡도가 O(N) or O(NlogN) 이지만 Heap은 O(logN)이라 압도적으로 효율이 좋음

때문에 우선순위큐를 쓴다하면 heap을 사용하는 것과 거의 같은 의미

# 파이썬에서

파이썬은 우선순위 큐를 위해 `heapq`라는 내장 모듈을 제공
`heapq`는 기본적으로 최소 힙(Min Heap)이다
즉, 숫자가 작은 것이 우선순위가 높음

```python

import heapq

q = []

# 1. 데이터 넣기 (Push)
heapq.heappush(q, 10)
heapq.heappush(q, 1)  # 1이 제일 작으므로 앞으로 옴
heapq.heappush(q, 5)

# 2. 데이터 꺼내기 (Pop) - 가장 작은 값부터 나옴
print(heapq.heappop(q)) # 1 출력
print(heapq.heappop(q)) # 5 출력
print(heapq.heappop(q)) # 10 출력
```

예시와 같이 순서 상관없이 우선순위 큐에 넣어도 가장 작은 값부터 출력됨을 확인 할수 있다.

```python
import heapq

q = []
nums = [1, 10, 5]

# 넣을 때: 부호를 마이너스로 바꿔서 넣음 (-1, -10, -5)
# 이러면 -10이 가장 작은 수가 되어 힙의 맨 앞에 위치함
for n in nums:
    heapq.heappush(q, -n) 

# 꺼낼 때: 다시 마이너스를 붙여서 원상복구
print(-heapq.heappop(q)) # -(-10) = 10 출력
```

마이너스로 부호를 바꾸는 방식으로 큰수부터 나오게 할수 있고 별도의 옵션은 존재하지 않는다.

# 어떤 상황에 쓸수 있을까?

## 1. 작업 스케줄러 (Task Scheduler)

백엔드가 서버로부터 요청을 받는데, 모든 요청이 평등하지 않음

- **일반 유저:** "내 프로필 사진 보여줘" (중요도 낮음)
    
- **VIP 유저:** "지금 당장 결제해줘" (중요도 높음)
    
- **시스템 알람:** "서버 다운 직전! 경고!" (긴급, 0순위)

만약 일반 큐(FIFO)를 쓰면, 앞에 쌓인 사진 요청 100개를 처리하느라 시스템 경고를 무시해서 서버가 죽을 수도 있음로 이때 우선순위 큐를 사용.

```python

import heapq

import time

class TaskScheduler:

    def __init__(self):

        self.queue = []
        self.index = 0  # 들어온 순서를 체크하기 위한 카운터

    def add_task(self, task_name, priority):

        # 힙에 저장할 구조: (우선순위, 들어온 순서, 작업 이름)

        # 우선순위 숫자가 작을수록 먼저 실행 (Min Heap 특성 활용)

        heapq.heappush(self.queue, (priority, self.index, task_name))

        self.index += 1

        print(f"[예약] '{task_name}' (우선순위: {priority})")

    def run_next(self):

        if not self.queue:

            return None

        # 가장 우선순위 높은 작업 꺼내기

        priority, _, task_name = heapq.heappop(self.queue)

        print(f"▶ [실행] '{task_name}' 처리 중... (우선순위: {priority})")

  

# --- 사용 예시 ---

scheduler = TaskScheduler()

  
# 1. 요청들이 무작위로 들어옴

scheduler.add_task("일반 유저 이미지 로딩", priority=3)

scheduler.add_task("VIP 유저 결제 요청", priority=1)  # 중요!

scheduler.add_task("시스템 로그 저장", priority=2)

scheduler.add_task("서버 과부하 긴급 패치", priority=0) # 긴급!

  
print("-" * 30)

# 2. 작업 실행 (들어온 순서와 상관없이 중요도 순으로 실행됨)

while scheduler.queue:

    scheduler.run_next()

    time.sleep(0.5)
    
```

실행결과

```plain text
[예약] '일반 유저 이미지 로딩' (우선순위: 3)
[예약] 'VIP 유저 결제 요청' (우선순위: 1)
[예약] '시스템 로그 저장' (우선순위: 2)
[예약] '서버 과부하 긴급 패치' (우선순위: 0)
------------------------------
▶ [실행] '서버 과부하 긴급 패치' 처리 중... (우선순위: 0)
▶ [실행] 'VIP 유저 결제 요청' 처리 중... (우선순위: 1)
▶ [실행] '시스템 로그 저장' 처리 중... (우선순위: 2)
▶ [실행] '일반 유저 이미지 로딩' 처리 중... (우선순위: 3)
```

## 2. 실시간 데이터 스트림의 Top-K 모니터링

지금 가장 응답이 느린 상위 3개 요청이 뭐지?"를 알고 싶은 경우. 매번 전체 데이터를 정렬(`sort`)하면 효율이 좋지 못하다. 힙을 사용하면 전체 데이터를 다 저장하지 않고도 상위 K개만 유지할 수 있음

100만개의 요청이 있을때 sort(NlogN)는 2000만번, heap(logN)은 20번

```python

import heapq
import random

def monitor_slow_requests(log_stream, k=3):
    # 상위 k개의 느린 요청만 담을 힙 (최소 힙)
    top_k_heap = []

    print(f"--- 실시간 로그 모니터링 시작 (Top {k} 느린 요청 추적) ---")

    for request_url, response_time in log_stream:
        # 1. 힙이 아직 꽉 차지 않았다면 그냥 넣음
        if len(top_k_heap) < k:
            heapq.heappush(top_k_heap, (response_time, request_url))
        else:
            # 2. 힙이 꽉 찼다면?
            # 현재 힙의 최소값(Top 3 중 3등)보다 지금 들어온 요청이 더 느리다면 교체 => 더 느린 응답으로 교체 
            if response_time > top_k_heap[0][0]:
                heapq.heappushpop(top_k_heap, (response_time, request_url))
                

    # 결과 출력 
    print(f"\n[최종 결과] 가장 느렸던 요청 Top {k}:")
    # 힙에서 꺼내면 작은 순서대로 나오므로 내림차순 정렬해서 보여줌
    result = sorted(top_k_heap, key=lambda x: x[0], reverse=True)
    for time, url in result:
        print(f"{time}ms - {url}")

# --- 더미 데이터 스트림 생성 ---
logs = [
    ("/home", 120), ("/about", 50), ("/api/pay", 3000), 
    ("/login", 200), ("/image/1.png", 80), ("/api/search", 4500),
    ("/favicon.ico", 10), ("/admin", 2100)
]

monitor_slow_requests(logs, k=3)
```

결과

```plaintext
[최종 결과] 가장 느렸던 요청 Top 3:
4500ms - /api/search
3000ms - /api/pay
2100ms - /admin
```

## 3. 다익스트라 알고리즘

최단경로를 위한 다익스트라 알고리즘에서도 사용됨

**1) 정의**: 한 곳에서 다른 모든 곳으로 가는 최단 거리

**2) 특징:**

- **음의 간선(비용)이 없어야 함:** 거리가 -5km인 도로는 현실에 없음 이런 비현실적인 상황이 없을 때만 작동한다.
    
- **그리디(Greedy) 알고리즘:** 매 순간 "지금 가장 가까운 곳"을 선택해서 이동하면, 결과적으로 전체 최단 거리가 구해진다는 논리.

**3) 로직**: 

- **초기화:** 출발지는 0, 나머지 출발점을 제외한 모든 노드는 무한대(`INF`)로 설정.
	
- **선택 (우선순위 큐 활용):** 방문하지 않은 노드 중 **가장 최단 거리가 짧은 노드**를 선택. (여기서 **최소 힙**을 사용! O(logN))
    
- **갱신 (Relaxation):** 선택한 노드를 거쳐서 다른 이웃 노드로 가는 게, 기존에 알고 있던 길보다 더 빠른지 확인. 더 빠르면 값을 갱신하고 큐에 넣는다.

무한대(`INF`) : 엄밀히 따지면 무한대가 아닌 아주 큰 수이다, 서울에서 부산가는 최단거리를 발견했을때 400km 라면 10억km와 비교해 작으니 최단거리를 400km로 수정

```python

import heapq

INF = int(1e9)  # 무한대 값


# n: 노드 개수, m: 간선 개수
n, m = map(int, input().split())

# 시작 노드 번호
start = int(input())


# 각 노드에 연결된 노드 정보를 담는 리스트 만들기
graph = [[] for i in range(n + 1)]

# 최단 거리 테이블을 모두 무한으로 초기화
distance = [INF] * (n + 1)

  

# 모든 간선 정보 입력받기
for _ in range(m):

    a, b, c = map(int, input().split())
    graph[a].append((b, c))

  

def dijkstra(start):

    q = []

    # 시작 노드로 가기 위한 최단 경로는 0으로 설정하여, 큐에 삽입

    heapq.heappush(q, (0, start))

    distance[start] = 0

  

    while q:

        # 가장 최단 거리가 짧은 노드에 대한 정보 꺼내기

        dist, now = heapq.heappop(q)

  

        # 현재 꺼낸 거리(dist)가 이미 기록된 거리(distance[now])보다 크다면 스킵

        if distance[now] < dist:

            continue

  

        # 현재 노드와 연결된 다른 인접한 노드들을 확인

        for i in graph[now]:

            cost = dist + i[1]

            # 현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우

            if cost < distance[i[0]]:

                distance[i[0]] = cost

                heapq.heappush(q, (cost, i[0]))

  

# 알고리즘 수행

dijkstra(start)

  

# 모든 노드로 가기 위한 최단 거리를 출력

for i in range(1, n + 1):

    if distance[i] == INF:

        print("INFINITY")

    else:

        print(distance[i])
        
```

노드 4개, 간선 5개일때 예시 시각화:
https://gemini.google.com/share/5c09db2e1ee7

# 힙(Heap)과 이진트리(Binary Tree)

우선순위 큐의 구현에는 힙이 사용 그리고 힙은 이진트리 구조이다.
때문에 두 개념또한 참고할 필요가 있다.

[[힙(heap)과 이진트리]]

