
두 배열에 원소들의 교집합의 갯수를 구하는 방법들에 대해 정리하고 비교 하였음

## 방법 1 : O(N·M)


```python
def intersect_nm(A, B):
    res = []
    for a in A:
        for b in B:
            if a == b:
                res.append(a)
                break
    return res

```

한배열의 원소를 다른 배열의 모든 원소에 대조 하여 일치할시 append 하는 방식이다.
각 배열의 갯수를 N, M 그리고 이중 for문이므로 N * M

- 사용경우
N과 M의 값에 따라 복잡도가 매우 커질 수 있으므로 작은 규모에서만 사용

## 방법 2 : O(N log M)

binary search를 활용한 방법이다

```python
from bisect import bisect_left

def intersect_nlogm(A, B):
    B_sorted = sorted(B)  # O(M log M)
    res = []
    for a in A:
        i = bisect_left(B_sorted, a)  # 이진탐색 : O(log M)
        
        if i < len(B_sorted) and B_sorted[i] == a:
            res.append(a)
    return res
# bisect_left(B_sorted, a)
# 정렬된 리스트 `B_sorted` 안에서 값 a가 들어갈 “가장 왼쪽 위치(인덱스)”를 이진탐색으로 찾아주는 함수
```

**B를 정렬해두고**, A의 각 원소를 **이진탐색**으로 찾기.

이진 탐색은 내부적으로는 어떤식으로 탐색을 하는가?

UP & DOWN 게임과 유사한 방식임

`low=0, high=len(B_sorted)` 범위를 두고,

- 중간 `mid`를 찍어 `B_sorted[mid] < a` 인지( UP인지 DOWN인지) 비교
    
- 맞으면 왼쪽 범위를 버리고 `low = mid+1`
    
- 아니면 `high = mid`  
    를 반복해서 **범위를 반씩 줄이는** 이진탐색을 함.  
    그래서 한 번 호출에 **O(log M)**.

시간복잡도 : O(M log M + N log M)

=> sorted 하는데 MlogM , 이진탐색 logM을 N번 == NlogM

이때 배열의 길이가 작은쪽은 정렬하는게 더 효율적이다.

**왜 작은 쪽을 정렬하는 게 유리한가?** 

두 배열 길이를 `N=len(A)`, `M=len(B)`라고 하고 **N ≤ M**라고 가정.

1) B(큰 쪽)를 정렬하고 A(작은 쪽)를 검색(=A 순회)

- 비용: `M log M` (정렬) + `N log M` (N번 이진탐색)
    
- 합: **M log M + N log M**

 2) A(작은 쪽)를 정렬하고 B(큰 쪽)를 검색(=B 순회)

- 비용: `N log N` (정렬) + `M log N` (M번 이진탐색)
    
- 합: **N log N + M log N**
    

이 둘을 비교하면 (① − ②):

(MlogM+NlogM)−(NlogN+MlogN)
=(M+N)(logM−logN)
=(M+N)log(M/N)≥0

즉 N ≤ M이면 2) 가 항상 같거나 더 작다(시간복잡도가) 
그래서 **작은 쪽을 정렬**하는 게 이론적으로도 유리.


- 사용경우
이미 정렬된 큰 데이터가 있고 새로 들어온 작은 데이터로 비교할때 사용

- **B : 엄청 큰 데이터, 이미 정렬/인덱스 되어 있음**
    
    - 예:
        
        - 허용된 IP 100만 개 리스트
            
        - 가입된 유저 ID 100만 개
            
        - DB 인덱스(전화번호, 이메일, 유저ID 같은 컬럼)
            
- **A : 그때그때 생기는 비교 대상, 상대적으로 작은 데이터**
    
    - 예:
        
        - “오늘 로그인 시도한 IP” 1000개
            
        - “오늘 주문한 유저 ID” 500개
            
        - “특정 캠페인에 노출된 유저 ID” 몇 천 개

이때 A에 있는 값들중 B에 있는 것을 골라내기


## 방법 3 : O(N log N + M log M)

투 포인터 알고리즘이라 한다 

 N 과 M인 입력이 주어졌을 때 각각을 한번씩 훑는 방식

```PYTHON
def intersect_two_pointers_set(A, B):
    A = sorted(A)
    B = sorted(B)

    i = j = 0
    res = []

    while i < len(A) and j < len(B):
        if A[i] == B[j]:
            # 직전에 넣은 값과 다를 때만 추가 → 중복 제거
            if not res or res[-1] != A[i]:
                res.append(A[i])
            i += 1
            j += 1
        elif A[i] < B[j]:
            i += 1
        else:
            j += 1

    return res


```


- `sorted(A)` → O(N log N)
    
- `sorted(B)` → O(M log M)
    
- 두 포인터 while 루프 → O(N+M)
    

그래서 전체 시간복잡도는

O(N log N + M log M + N + M) = O(N log N + M log M)

- 사용경우
두 배열 모두 이미 정렬되어 있다면 시간복잡도가 O(N+M)이라 쓰기 좋음

## 방법 4 : O(N+M)

```python
def intersect_hashset(A, B):
    # 1) A의 모든 원소를 해시셋에 넣기  -> O(N)
    s = set(A)

    res = []
    # 2) B를 돌면서 s 안에 있는지 확인 -> O(M)
    for x in B:
        if x in s:
            res.append(x)
            s.remove(x)   

    return res

```

- `set(A)` 만드는 데: A의 원소 N개를 한 번씩 넣으니 **O(N)**
    
- for 루프로 B의 원소 M개를 한 번씩 보면서 `x in s` 검사 → 각 검사 평균 **O(1)** → 전체 **O(M)**
    

그래서 전체 시간복잡도는  **O(N) + O(M) = O(N+M)** 

- 사용경우

교집합 요소 탐색시 가장 많이 사용됨
- 투포인터:
    
    - 정렬 + 인덱스 두 개 + while문 + 조건 처리…
        
- 이진탐색:
    
    - 정렬 + bisect_left + 인덱스 체크…

인데 반해 하나를 set한다음 존재여부 확인 하는 방식이라 직관적이고 시간복잡도도 작은 편

---

## 병합정렬은 왜 NlogN 일까

### 비유 1) “층이 log N개인 아파트” + “각 층에 N명이 한 번씩 지나감”

병합정렬은

- 반으로 쪼개는 과정 때문에 **층(단계)** 이 **log N개** 생긴다.
    
- 그런데 **각 층에서** 원소들이 “합치기(merge)”를 하느라 전체 원소 N개가 한 번씩은 꼭 움직이게 된다..
    

즉 매 층마다:

- 1층에서도 N명이 한 번씩 지나가고
    
- 2층에서도 N명이 한 번씩 지나가고
    
- …
    
- log N층까지 계속
    

그래서 총 지나간 횟수는  
**N(한 층에서 지나가는 사람 수) × log N(층 수)**.

---

### 비유 2) “카드 8장 정렬”을 손으로 합치기

N=8이면 log₂8=3층

### 층 1: 1장+1장 합치기 (4번)

- (1+1) 합치기 4번 = 카드 총 8장이 결과로 이동
    

### 층 2: 2장+2장 합치기 (2번)

- (2+2) 합치기 2번 = 카드 총 8장이 결과로 이동
    

### 층 3: 4장+4장 합치기 (1번)

- (4+4) 합치기 1번 = 카드 총 8장이 결과로 이동
    

핵심: **각 층마다 “카드 8장 전체”가 한 번씩 결과로 복사/이동됨**  
→ 층마다 비용이 N(=8)

층이 3개니까 총 이동/비교가 대략  
**8 + 8 + 8 = 8×3 = N×logN**



