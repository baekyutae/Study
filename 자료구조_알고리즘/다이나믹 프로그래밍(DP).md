
# 정의

다이나믹 프로그래밍이란, **큰 문제를 작은 문제로 나눌 수 있고 그 작은 문제들이 반복**될 때, **한 번 계산한 결과를 메모리에 저장(Cashing/Memoization)** 하여 중복 계산을 방지함으로써 전체적인 연산 속도를 비약적으로 향상시키는 알고리즘이다.

위와 같은 문제의 대표적인 예시로 피보나치 수열이 존재

피보나치 수열은 N번째 항의 값을 알려면 N-1번째 항과 N-2번째 항의 값을 더해야 한다.

예를들어 5번 피보나치 수를 구한다 가정하면

- **5번:** "4번아, 3번의 항이 필요"
    
- **4번:** "3번 2번 항이 필요."
    
- **3번:** "2번 1번 항이 필요.<BR>

즉 4번 항에서 3번항의 값을 구해 더했지만 5번 항을 구할떄 또 3번항을 구해야한다.

- F(5)를 구하기 위해 F(3)은 2번 계산.
    
- F(2)는 3번이나 계산.<BR>

숫자가 커질 수록 이처럼 중복되는 횟수는 기하급수적으로 늘어남
또한 항이 늘어날수록 구해야 할 항의 갯수가 2개씩 늘어나니 시간복잡도 상으로 O(n^2)이 나옴

n이 30만 되어도 약 10억 가량의 연산을 해야함


이럴때 다이나믹 프로그래밍이 그 해결책이 될수 있으며 아래 두가지 조건을 충족시키는 경우 사용가능하다.

1. 큰 문제를 작은 문제로 나눌 수 있다
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.


# 메모이제이션

메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 한 종류로 한번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법이다.
값을 저장하는 방법이므로 캐싱이라고도 한다.
<br>
한번 구한 정보를 리스트에 저장하는 방식으로 구현
<br>
피보나치 수열을 메모이제이션으로 구현하면 아래와 같다.
```python
# 한번 계산된 결과를 메모이제이션 하기 위한 리스트 초기화
d = [0]*100

# 피보나치 함수를 재귀함수로 구현
def fibo(x):
	if x == 1 or x == 2:
		return 1
	# 이미 계산해서 리스트에 저장된 값이면 반환
	if d[x] != 0:
		return d[x]
	# 아직 계산 하지 않은 문제면 점화식으로 피보나치 결과 반환
	# 점화식: 이웃하는 항들의 관계를 나타낸 식
	d[x] = fibo(x-1) + fibo(x-2)
	return d[x]
	 
```

# 분할정복과의 차이점

리스트에서 pivot을 하나 정해 반으로 나눠 정렬을 하는 퀵정렬은 분할정복 알고리즘으로 분류된다. 다이나믹 프로그래밍과의 차이점은 DP는 반으로 나누었을 때 똑같은 부분 문제가 반복해서 나타난다. 

EX)위의 예시에서 F(6)을 구할떄 3번항이 두번 나옴
<BR>
그러나 분할정복은 Pivot을 기준으로 반으로 나누었을 떄 서로 아무런 관련이 없다. 또한 DP는 기록을 하지만 분할정복은 하지 않는다.


# Top-Down VS Bottom-Up

지금까지 설명한 dp 방식은 재귀 함수를 이용하여 큰문제를 해결하기 위해 작은 문제를 호출한다 하여 탑 다운 방식이라고 한다. 반면에 단순히 반복문만 활용하여 소스코드를 작성 하는 경우 보텀업 방식이라 한다.<br>
바텀업 방식은 아래와 같다
```python
# DP 테이블
d = [0]*100

# 앞의 두항이 있어야 피보나치 수열이 성립하므로
d[1] = 1
d[2] = 1
n = 99

for i in range(3. n+1):
	d[i] = d[i-1] + d[i-2]
```

탑 다운 방식은 하향식 이라고도 하며 보텀업 방식은 상향식이라고도 한다.
보텀업 방식에서 사용되는 결과 저장용 리스트는 DP테이블 이라고 부르며 메모이제이션은 탑다운 방식에 국한되어 사용되는 표현이다.<BR>
메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념이며 경우에 따라 리스트 말고 다른 자료형을 사용하여 결과를 저장하기도 함<BR>
가능하다면 보텀업 방식이 DP에서 권장되는데 경우에 따라 재귀함수의 스택의 크기가 제한된 경우에는 탑 다운 방식이 사용불가 하기 때문이다.